/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = T | U extends object
  ? (Without<T, U> & U) | (Without<U, T> & T)
  : T | U;
/* eslint-disable @typescript-eslint/no-explicit-any */
type OneOf<T extends any[]> = T extends [infer Only]
  ? Only
  : T extends [infer A, infer B, ...infer Rest]
  ? OneOf<[XOR<A, B>, ...Rest]>
  : never;
/* eslint-enable @typescript-eslint/no-explicit-any */

export interface paths {
  '/info': {
    /**
     * Info
     * @description Get information about the block explorer.
     * Response contains a semver formatted version of the data node and the commit hash, from which the block explorer was built
     */
    get: operations['BlockExplorer_Info'];
  };
  '/transactions': {
    /**
     * List transactions
     * @description List transactions from the Vega blockchain
     */
    get: operations['BlockExplorer_ListTransactions'];
  };
  '/transactions/{hash}': {
    /**
     * Get transaction
     * @description Get a transaction from the Vega blockchain
     */
    get: operations['BlockExplorer_GetTransaction'];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /**
     * @description Operator describes the type of comparison.
     *
     *  - OPERATOR_UNSPECIFIED: The default value
     *  - OPERATOR_EQUALS: Verify if the property values are strictly equal or not.
     *  - OPERATOR_GREATER_THAN: Verify if the data source data value is greater than the Condition value.
     *  - OPERATOR_GREATER_THAN_OR_EQUAL: Verify if the data source data value is greater than or equal to the Condition
     * value.
     *  - OPERATOR_LESS_THAN: Verify if the data source data value is less than the Condition value.
     *  - OPERATOR_LESS_THAN_OR_EQUAL: Verify if the data source data value is less or equal to than the Condition
     * value.
     * @default OPERATOR_UNSPECIFIED
     * @enum {string}
     */
    readonly ConditionOperator:
      | 'OPERATOR_UNSPECIFIED'
      | 'OPERATOR_EQUALS'
      | 'OPERATOR_GREATER_THAN'
      | 'OPERATOR_GREATER_THAN_OR_EQUAL'
      | 'OPERATOR_LESS_THAN'
      | 'OPERATOR_LESS_THAN_OR_EQUAL';
    /**
     * Supported oracle sources
     * @description - ORACLE_SOURCE_UNSPECIFIED: Default value
     *  - ORACLE_SOURCE_OPEN_ORACLE: Specifies that the payload will be base64 encoded JSON conforming to the Open Oracle standard
     *  - ORACLE_SOURCE_JSON: Specifies that the payload will be base64 encoded JSON, but does not specify the shape of the data
     * @default ORACLE_SOURCE_UNSPECIFIED
     * @enum {string}
     */
    readonly OracleDataSubmissionOracleSource:
      | 'ORACLE_SOURCE_UNSPECIFIED'
      | 'ORACLE_SOURCE_OPEN_ORACLE'
      | 'ORACLE_SOURCE_JSON';
    /**
     * Time In Force for an order
     * @description - TIME_IN_FORCE_UNSPECIFIED: Default value for TimeInForce, can be valid for an amend
     *  - TIME_IN_FORCE_GTC: Good until cancelled, the order trades any amount and as much as possible
     * and remains on the book until it either trades completely or is cancelled
     *  - TIME_IN_FORCE_GTT: Good until specified time, this order type trades any amount and as much as possible
     * and remains on the book until it either trades completely, is cancelled, or expires at a set time
     * NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
     *  - TIME_IN_FORCE_IOC: Immediate or cancel, the order trades any amount and as much as possible
     * but does not remain on the book (whether it trades or not)
     *  - TIME_IN_FORCE_FOK: Fill or kill, the order either trades completely i.e. remainingSize == 0 after adding,
     * or not at all, and does not remain on the book if it doesn't trade
     *  - TIME_IN_FORCE_GFA: Good for auction, this order is only accepted during an auction period
     *  - TIME_IN_FORCE_GFN: Good for normal, this order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)
     * @default TIME_IN_FORCE_UNSPECIFIED
     * @enum {string}
     */
    readonly OrderTimeInForce:
      | 'TIME_IN_FORCE_UNSPECIFIED'
      | 'TIME_IN_FORCE_GTC'
      | 'TIME_IN_FORCE_GTT'
      | 'TIME_IN_FORCE_IOC'
      | 'TIME_IN_FORCE_FOK'
      | 'TIME_IN_FORCE_GFA'
      | 'TIME_IN_FORCE_GFN';
    /**
     * @description  - EXPIRY_STRATEGY_UNSPECIFIED: Never valid
     *  - EXPIRY_STRATEGY_CANCELS: Stop order should be cancelled if the expiry time is reached.
     *  - EXPIRY_STRATEGY_SUBMIT: Order should be submitted if the expiry time is reached.
     * @default EXPIRY_STRATEGY_UNSPECIFIED
     * @enum {string}
     */
    readonly StopOrderExpiryStrategy:
      | 'EXPIRY_STRATEGY_UNSPECIFIED'
      | 'EXPIRY_STRATEGY_CANCELS'
      | 'EXPIRY_STRATEGY_SUBMIT';
    /**
     * @default METHOD_UNSPECIFIED
     * @enum {string}
     */
    readonly UndelegateSubmissionMethod:
      | 'METHOD_UNSPECIFIED'
      | 'METHOD_NOW'
      | 'METHOD_AT_END_OF_EPOCH';
    readonly blockexplorerapiv1Transaction: {
      /**
       * Height of the block the transaction was found in
       * Format: uint64
       */
      readonly block?: string;
      /**
       * Results code of the transaction. 0 indicates the transaction was successful
       * Format: int64
       */
      readonly code?: number;
      /** Actual command of the transaction */
      readonly command?: components['schemas']['v1InputData'];
      /** Cursor for this transaction. This is used for paginating results */
      readonly cursor?: string;
      /**
       * Optional error happening when processing / checking the transaction
       * This should be set if error code is not 0
       */
      readonly error?: string;
      /** Hash of the transaction */
      readonly hash?: string;
      /**
       * Index of the transaction in the block
       * Format: int64
       */
      readonly index?: number;
      /** Signature generated by the submitter for the transaction */
      readonly signature?: components['schemas']['v1Signature'];
      /** Vega public key of the transaction's submitter */
      readonly submitter?: string;
      /** Type of transaction */
      readonly type?: string;
    };
    /** Request for cancelling a recurring transfer */
    readonly commandsv1CancelTransfer: {
      /** @description Transfer ID of the transfer to cancel. */
      readonly transferId?: string;
    };
    /** Specific details for a one off transfer */
    readonly commandsv1OneOffTransfer: {
      /**
       * Format: int64
       * @description Timestamp in Unix nanoseconds for when the transfer should be delivered into the receiver's account.
       */
      readonly deliverOn?: string;
    };
    /** Specific details for a recurring transfer */
    readonly commandsv1RecurringTransfer: {
      /** @description Optional parameter defining how a transfer is dispatched. */
      readonly dispatchStrategy?: components['schemas']['vegaDispatchStrategy'];
      /**
       * Format: uint64
       * @description Last epoch at which this transfer shall be paid.
       */
      readonly endEpoch?: string;
      /** @description Factor needs to be > 0. */
      readonly factor?: string;
      /**
       * Format: uint64
       * @description First epoch from which this transfer shall be paid.
       */
      readonly startEpoch?: string;
    };
    /** Transfer initiated by a party */
    readonly commandsv1Transfer: {
      /** @description Amount to be taken from the source account. This field is an unsigned integer scaled to the asset's decimal places. */
      readonly amount?: string;
      /** @description Asset ID of the asset to be transferred. */
      readonly asset?: string;
      /**
       * @description Account type from which the funds of the party
       * should be taken.
       */
      readonly fromAccountType?: components['schemas']['vegaAccountType'];
      readonly oneOff?: components['schemas']['commandsv1OneOffTransfer'];
      readonly recurring?: components['schemas']['commandsv1RecurringTransfer'];
      /** @description Reference to be attached to the transfer. */
      readonly reference?: string;
      /** @description Public key of the destination account. */
      readonly to?: string;
      /** @description Type of the destination account. */
      readonly toAccountType?: components['schemas']['vegaAccountType'];
    };
    readonly googlerpcStatus: {
      /** Format: int32 */
      readonly code?: number;
      readonly details?: readonly components['schemas']['protobufAny'][];
      readonly message?: string;
    };
    readonly protobufAny: {
      readonly '@type'?: string;
      [key: string]: unknown;
    };
    /**
     * @description `NullValue` is a singleton enumeration to represent the null value for the
     * `Value` type union.
     *
     *  The JSON representation for `NullValue` is JSON `null`.
     *
     *  - NULL_VALUE: Null value.
     * @default NULL_VALUE
     * @enum {string}
     */
    readonly protobufNullValue: 'NULL_VALUE';
    /** Used to announce a node as a new pending validator */
    readonly v1AnnounceNode: {
      /** @description AvatarURL of the validator. */
      readonly avatarUrl?: string;
      /** @description Public key for the blockchain, required field. */
      readonly chainPubKey?: string;
      /** @description Country code (ISO 3166-1 alpha-2) for the location of the node. */
      readonly country?: string;
      /** @description Ethereum public key, required field. */
      readonly ethereumAddress?: string;
      /** @description Signature from the validator made using the ethereum wallet. */
      readonly ethereumSignature?: components['schemas']['v1Signature'];
      /**
       * Format: uint64
       * @description Epoch from which the validator is expected
       * to be ready to validate blocks.
       */
      readonly fromEpoch?: string;
      /** @description Node ID of the validator, i.e. the node's public master key. */
      readonly id?: string;
      /** @description URL with more info on the node. */
      readonly infoUrl?: string;
      /** @description Name of the validator. */
      readonly name?: string;
      /** @description Ethereum public key to use as a submitter to allow automatic signature generation. */
      readonly submitterAddress?: string;
      /** @description Vega public key, required field. */
      readonly vegaPubKey?: string;
      /**
       * Format: int64
       * @description Vega public key derivation index.
       */
      readonly vegaPubKeyIndex?: number;
      /** @description Signature from the validator made using the Vega wallet. */
      readonly vegaSignature?: components['schemas']['v1Signature'];
    };
    /**
     * Batch of order instructions.
     * This command accepts only the following batches of commands
     * and will be processed in the following order:
     * - OrderCancellation
     * - OrderAmendment
     * - OrderSubmission
     * The total amount of commands in the batch across all three lists of
     * instructions is restricted by the following network parameter:
     * "spam.protection.max.batchSize"
     */
    readonly v1BatchMarketInstructions: {
      /** @description List of order amendments to be processed sequentially. */
      readonly amendments?: readonly components['schemas']['v1OrderAmendment'][];
      /** @description List of order cancellations to be processed sequentially. */
      readonly cancellations?: readonly components['schemas']['v1OrderCancellation'][];
      /** @description List of stop order cancellations to be processed sequentially. */
      readonly stopOrdersCancellation?: readonly components['schemas']['v1StopOrdersCancellation'][];
      /** @description List of stop order submissions to be processed sequentially. */
      readonly stopOrdersSubmission?: readonly components['schemas']['v1StopOrdersSubmission'][];
      /** @description List of order submissions to be processed sequentially. */
      readonly submissions?: readonly components['schemas']['v1OrderSubmission'][];
    };
    /** Event forwarded to the Vega network to provide information on events happening on other networks */
    readonly v1ChainEvent: {
      /** @description Built-in asset event. */
      readonly builtin?: components['schemas']['vegaBuiltinAssetEvent'];
      /** Arbitrary contract call */
      readonly contractCall?: components['schemas']['vegaEthContractCallEvent'];
      /** @description Ethereum ERC20 event. */
      readonly erc20?: components['schemas']['vegaERC20Event'];
      /** @description Ethereum ERC20 multisig event. */
      readonly erc20Multisig?: components['schemas']['vegaERC20MultiSigEvent'];
      /**
       * Format: uint64
       * @description Arbitrary one-time integer used to prevent replay attacks.
       */
      readonly nonce?: string;
      /** @description Ethereum Staking event. */
      readonly stakingEvent?: components['schemas']['vegaStakingEvent'];
      /** @description Transaction ID of the transaction in which the events happened, usually a hash. */
      readonly txId?: string;
    };
    /** Condition describes the condition that must be validated by the network */
    readonly v1Condition: {
      /** @description Type of comparison to make on the value. */
      readonly operator?: components['schemas']['ConditionOperator'];
      /** @description Value to be compared with by the operator. */
      readonly value?: string;
    };
    /** Command to submit an instruction to delegate some stake to a node */
    readonly v1DelegateSubmission: {
      /** @description Amount of stake to delegate. This field is an unsigned integer scaled to the asset's decimal places. */
      readonly amount?: string;
      /** @description Delegate to the specified node ID. */
      readonly nodeId?: string;
    };
    readonly v1ETHAddress: {
      readonly address?: string;
    };
    /** Transaction to allow a validator to rotate their ethereum keys */
    readonly v1EthereumKeyRotateSubmission: {
      /** @description Currently used public address. */
      readonly currentAddress?: string;
      /** @description Signature that can be verified using the new ethereum address. */
      readonly ethereumSignature?: components['schemas']['v1Signature'];
      /** @description New address to rotate to. */
      readonly newAddress?: string;
      /** @description Ethereum public key to use as a submitter to allow automatic signature generation. */
      readonly submitterAddress?: string;
      /**
       * Format: uint64
       * @description Target block at which the key rotation will take effect on.
       */
      readonly targetBlock?: string;
    };
    /**
     * @description Filter describes the conditions under which a data source data is considered of
     * interest or not.
     */
    readonly v1Filter: {
      /**
       * @description Conditions that should be matched by the data to be
       * considered of interest.
       */
      readonly conditions?: readonly components['schemas']['v1Condition'][];
      /** @description Data source's data property key targeted by the filter. */
      readonly key?: components['schemas']['v1PropertyKey'];
    };
    readonly v1GetTransactionResponse: {
      /** Transaction corresponding to the hash */
      readonly transaction?: components['schemas']['blockexplorerapiv1Transaction'];
    };
    /** Iceberg order options */
    readonly v1IcebergOpts: {
      /**
       * Format: uint64
       * @description Minimum allowed remaining size of the order before it is replenished back to its peak size.
       */
      readonly minimumVisibleSize?: string;
      /**
       * Format: uint64
       * @description Size of the order that is made visible and can be traded with during the execution of a single order.
       */
      readonly peakSize?: string;
    };
    readonly v1InfoResponse: {
      /** Commit hash from which the data node was built */
      readonly commitHash?: string;
      /** Semver formatted version of the data node */
      readonly version?: string;
    };
    readonly v1InputData: {
      /** @description Command used by a node operator to announce its node as a pending validator. */
      readonly announceNode?: components['schemas']['v1AnnounceNode'];
      /** @description Command to submit a batch of order instructions to a market. */
      readonly batchMarketInstructions?: components['schemas']['v1BatchMarketInstructions'];
      /**
       * Format: uint64
       * @description Block height at which the transaction was made.
       * This should be the current block height. The transaction will be valid
       * from the block and up to the `tolerance` block height.
       * Example: If the network has a tolerance of 150 blocks and `block_height`
       * is set to `200`, then the transaction will be valid until block `350`.
       * Note that a `block_height` that is ahead of the real block height will be
       * rejected. The tolerance can be queried from the chain's network parameters.
       * `block_height` prevents replay attacks in conjunction with `nonce` (see above).
       */
      readonly blockHeight?: string;
      /** @description Command to request cancelling a recurring transfer. */
      readonly cancelTransfer?: components['schemas']['commandsv1CancelTransfer'];
      /**
       * @description Command used by a validator to submit an event forwarded to the Vega network to provide information
       * on events happening on other networks, to be used by a foreign chain
       * to recognise a decision taken by the Vega network.
       */
      readonly chainEvent?: components['schemas']['v1ChainEvent'];
      /** @description Command to delegate tokens to a validator. */
      readonly delegateSubmission?: components['schemas']['v1DelegateSubmission'];
      /** @description Command used by a validator to allow given validator to rotate their Ethereum keys. */
      readonly ethereumKeyRotateSubmission?: components['schemas']['v1EthereumKeyRotateSubmission'];
      /** @description Command used by a validator to submit signatures to a smart contract. */
      readonly issueSignatures?: components['schemas']['v1IssueSignatures'];
      /** @description Command used by a validator to allow given validator to rotate their Vega keys. */
      readonly keyRotateSubmission?: components['schemas']['v1KeyRotateSubmission'];
      /** @description Command to request amending a liquidity commitment. */
      readonly liquidityProvisionAmendment?: components['schemas']['v1LiquidityProvisionAmendment'];
      /** @description Command to request cancelling a liquidity commitment. */
      readonly liquidityProvisionCancellation?: components['schemas']['v1LiquidityProvisionCancellation'];
      /** @description Command to submit a liquidity commitment. */
      readonly liquidityProvisionSubmission?: components['schemas']['v1LiquidityProvisionSubmission'];
      /** @description Command used by a validator to submit a signature, to be used by a foreign chain to recognise a decision taken by the Vega network. */
      readonly nodeSignature?: components['schemas']['v1NodeSignature'];
      /**
       * @description Command used by a validator when a node votes for validating that a given resource exists or is valid,
       * for example, an ERC20 deposit is valid and exists on ethereum.
       */
      readonly nodeVote?: components['schemas']['v1NodeVote'];
      /**
       * Format: uint64
       * @description Number to provide uniqueness to prevent accidental replays and,
       * in combination with `block_height`, deliberate attacks.
       * A nonce provides uniqueness for otherwise identical transactions,
       * ensuring that the transaction hash uniquely identifies a specific transaction.
       * Granted all other fields are equal, the nonce can either be a counter
       * or generated at random to submit multiple transactions within the same
       * block (see below), without being identified as replays.
       * Please note that Protocol Buffers do not have a canonical, unique encoding
       * and therefore different libraries or binaries may encode the same message
       * slightly differently, causing a different hash.
       */
      readonly nonce?: string;
      /** @description Command to submit new oracle data from third party providers. */
      readonly oracleDataSubmission?: components['schemas']['v1OracleDataSubmission'];
      /** @description Command to amend an order. */
      readonly orderAmendment?: components['schemas']['v1OrderAmendment'];
      /** @description Command to cancel an order. */
      readonly orderCancellation?: components['schemas']['v1OrderCancellation'];
      /** @description Command for submitting an order. */
      readonly orderSubmission?: components['schemas']['v1OrderSubmission'];
      /** @description Command to submit a governance proposal. */
      readonly proposalSubmission?: components['schemas']['v1ProposalSubmission'];
      /** @description Command used by a validator to propose a protocol upgrade. */
      readonly protocolUpgradeProposal?: components['schemas']['v1ProtocolUpgradeProposal'];
      /** @description Command used by a validator to submit a floating point value. */
      readonly stateVariableProposal?: components['schemas']['v1StateVariableProposal'];
      /** @description Command to cancel stop orders. */
      readonly stopOrdersCancellation?: components['schemas']['v1StopOrdersCancellation'];
      /** @description Command to submit a pair of stop orders. */
      readonly stopOrdersSubmission?: components['schemas']['v1StopOrdersSubmission'];
      /** @description Command to submit a transfer. */
      readonly transfer?: components['schemas']['commandsv1Transfer'];
      /** @description Command to remove tokens delegated to a validator. */
      readonly undelegateSubmission?: components['schemas']['v1UndelegateSubmission'];
      /**
       * @description Command used by a validator to signal they are still online and validating blocks
       * or ready to validate blocks when they are still a pending validator.
       */
      readonly validatorHeartbeat?: components['schemas']['v1ValidatorHeartbeat'];
      /** @description Command to submit a vote on a governance proposal. */
      readonly voteSubmission?: components['schemas']['v1VoteSubmission'];
      /** @description Command to submit a withdrawal. */
      readonly withdrawSubmission?: components['schemas']['v1WithdrawSubmission'];
    };
    /** Transaction for a validator to submit signatures to a smart contract */
    readonly v1IssueSignatures: {
      /** @description What kind of signatures to generate, namely for whether a signer is being added or removed. */
      readonly kind?: components['schemas']['v1NodeSignatureKind'];
      /** @description Ethereum address which will submit the signatures to the smart contract. */
      readonly submitter?: string;
      /** @description Node ID of the validator node that will be signed in or out of the smart contract. */
      readonly validatorNodeId?: string;
    };
    /** Transaction to allow a validator to rotate their Vega keys */
    readonly v1KeyRotateSubmission: {
      /** @description Hash of currently used public key. */
      readonly currentPubKeyHash?: string;
      /** @description New public key to rotate to. */
      readonly newPubKey?: string;
      /**
       * Format: int64
       * @description New Vega public key derivation index.
       */
      readonly newPubKeyIndex?: number;
      /**
       * Format: uint64
       * @description Target block at which the key rotation will take effect on.
       */
      readonly targetBlock?: string;
    };
    /** Amend a liquidity provision request */
    readonly v1LiquidityProvisionAmendment: {
      readonly buys?: readonly components['schemas']['vegaLiquidityOrder'][];
      /** @description From here at least one of the following is required to consider the command valid. */
      readonly commitmentAmount?: string;
      readonly fee?: string;
      /** @description Unique ID for the market with the liquidity provision to be amended. */
      readonly marketId?: string;
      readonly reference?: string;
      readonly sells?: readonly components['schemas']['vegaLiquidityOrder'][];
    };
    /** Cancel a liquidity provision request */
    readonly v1LiquidityProvisionCancellation: {
      /** @description Unique ID for the market with the liquidity provision to be cancelled. */
      readonly marketId?: string;
    };
    /** A liquidity provision submitted for a given market */
    readonly v1LiquidityProvisionSubmission: {
      /** @description Set of liquidity buy orders to meet the liquidity provision obligation. */
      readonly buys?: readonly components['schemas']['vegaLiquidityOrder'][];
      /**
       * @description Specified as a unitless number that represents the amount of settlement asset of the market.
       * This field is an unsigned integer scaled using the asset's decimal places.
       */
      readonly commitmentAmount?: string;
      /** @description Nominated liquidity fee factor, which is an input to the calculation of taker fees on the market, as per setting fees and rewarding liquidity providers. */
      readonly fee?: string;
      /** @description Market ID for the order. */
      readonly marketId?: string;
      /** @description Reference to be added to every order created out of this liquidity provision submission. */
      readonly reference?: string;
      /** @description Set of liquidity sell orders to meet the liquidity provision obligation. */
      readonly sells?: readonly components['schemas']['vegaLiquidityOrder'][];
    };
    readonly v1ListTransactionsResponse: {
      /** Transaction corresponding to the specific request and filters */
      readonly transactions?: readonly components['schemas']['blockexplorerapiv1Transaction'][];
    };
    /** Represents a signature from a validator, to be used by a foreign chain in order to recognise a decision taken by the Vega network */
    readonly v1NodeSignature: {
      /** @description ID of the resource being signed. */
      readonly id?: string;
      /** @description Kind of resource being signed. */
      readonly kind?: components['schemas']['v1NodeSignatureKind'];
      /**
       * Format: byte
       * @description The signature generated by the signer.
       */
      readonly sig?: string;
    };
    /**
     * Kind of signature created by a node, for example, allow-listing a new asset, withdrawal etc
     * @description - NODE_SIGNATURE_KIND_UNSPECIFIED: Represents an unspecified or missing value from the input
     *  - NODE_SIGNATURE_KIND_ASSET_NEW: Represents a signature for a new asset allow-listing
     *  - NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL: Represents a signature for an asset withdrawal
     *  - NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED: Represents a signature for a new signer added to the erc20 multisig contract
     *  - NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED: Represents a signature for a signer removed from the erc20 multisig contract
     *  - NODE_SIGNATURE_KIND_ASSET_UPDATE: Represents a signature for an asset update allow-listing
     * @default NODE_SIGNATURE_KIND_UNSPECIFIED
     * @enum {string}
     */
    readonly v1NodeSignatureKind:
      | 'NODE_SIGNATURE_KIND_UNSPECIFIED'
      | 'NODE_SIGNATURE_KIND_ASSET_NEW'
      | 'NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL'
      | 'NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED'
      | 'NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED'
      | 'NODE_SIGNATURE_KIND_ASSET_UPDATE';
    /**
     * @description Used when a node votes for validating that a given resource exists or is valid,
     * for example, an ERC20 deposit is valid and exists on ethereum.
     */
    readonly v1NodeVote: {
      /** @description Reference identifying the resource making the vote, required field. */
      readonly reference?: string;
      /** @description Type of NodeVote, also required. */
      readonly type?: components['schemas']['v1NodeVoteType'];
    };
    /**
     * - TYPE_UNSPECIFIED: Represents an unspecified or missing value from the input
     *  - TYPE_STAKE_DEPOSITED: Node vote for a new stake deposit
     *  - TYPE_STAKE_REMOVED: Node vote for a new stake removed event
     *  - TYPE_FUNDS_DEPOSITED: Node vote for a new collateral deposit
     *  - TYPE_SIGNER_ADDED: Node vote for a new signer added to the erc20 bridge
     *  - TYPE_SIGNER_REMOVED: Node vote for a signer removed from the erc20 bridge
     *  - TYPE_BRIDGE_STOPPED: Node vote for a bridge stopped event
     *  - TYPE_BRIDGE_RESUMED: Node vote for a bridge resumed event
     *  - TYPE_ASSET_LISTED: Node vote for a newly listed asset
     *  - TYPE_LIMITS_UPDATED: Node vote for an asset limits update
     *  - TYPE_STAKE_TOTAL_SUPPLY: Node vote to share the total supply of the staking token
     *  - TYPE_SIGNER_THRESHOLD_SET: Node vote to update the threshold of the signer set for the multisig contract
     *  - TYPE_GOVERNANCE_VALIDATE_ASSET: Node vote to validate a new assert governance proposal
     * @default TYPE_UNSPECIFIED
     * @enum {string}
     */
    readonly v1NodeVoteType:
      | 'TYPE_UNSPECIFIED'
      | 'TYPE_STAKE_DEPOSITED'
      | 'TYPE_STAKE_REMOVED'
      | 'TYPE_FUNDS_DEPOSITED'
      | 'TYPE_SIGNER_ADDED'
      | 'TYPE_SIGNER_REMOVED'
      | 'TYPE_BRIDGE_STOPPED'
      | 'TYPE_BRIDGE_RESUMED'
      | 'TYPE_ASSET_LISTED'
      | 'TYPE_LIMITS_UPDATED'
      | 'TYPE_STAKE_TOTAL_SUPPLY'
      | 'TYPE_SIGNER_THRESHOLD_SET'
      | 'TYPE_GOVERNANCE_VALIDATE_ASSET';
    /** Command to submit new Oracle data from third party providers */
    readonly v1OracleDataSubmission: {
      /**
       * Format: byte
       * @description Data provided by the data source
       * In the case of Open Oracle - it will be the entire object - it will contain messages, signatures and price data.
       */
      readonly payload?: string;
      /**
       * @description Source from which the data is coming from. Must be base64 encoded.
       * Oracle data is a type of external data source data.
       */
      readonly source?: components['schemas']['OracleDataSubmissionOracleSource'];
    };
    /** An order amendment is a request to amend or update an existing order on Vega */
    readonly v1OrderAmendment: {
      /**
       * Format: int64
       * @description Amend the expiry time for the order, if the Timestamp value is set, otherwise expiry time will remain unchanged.
       */
      readonly expiresAt?: string;
      /** @description Market ID, this is required to find the order and will not be updated. */
      readonly marketId?: string;
      /** @description Order ID, this is required to find the order and will not be updated, required field. */
      readonly orderId?: string;
      /** @description Amend the pegged order offset for the order. This field is an unsigned integer scaled to the market's decimal places. */
      readonly peggedOffset?: string;
      /** @description Amend the pegged order reference for the order. */
      readonly peggedReference?: components['schemas']['vegaPeggedReference'];
      /**
       * @description Amend the price for the order if the price value is set, otherwise price will remain unchanged.
       * This field is an unsigned integer scaled to the market's decimal places.
       */
      readonly price?: string;
      /**
       * Format: int64
       * @description Amend the size for the order by the delta specified:
       * - To reduce the size from the current value set a negative integer value
       * - To increase the size from the current value, set a positive integer value
       * - To leave the size unchanged set a value of zero
       * This field needs to be scaled using the market's position decimal places.
       */
      readonly sizeDelta?: string;
      /** @description Amend the time in force for the order, set to TIME_IN_FORCE_UNSPECIFIED to remain unchanged. */
      readonly timeInForce?: components['schemas']['OrderTimeInForce'];
    };
    /** Order cancellation is a request to cancel an existing order on Vega */
    readonly v1OrderCancellation: {
      /** @description Market ID for the order, required field. */
      readonly marketId?: string;
      /** @description Unique ID for the order. This is set by the system after consensus. Required field. */
      readonly orderId?: string;
    };
    /** Order submission is a request to submit or create a new order on Vega */
    readonly v1OrderSubmission: {
      /**
       * Format: int64
       * @description Timestamp in Unix nanoseconds for when the order will expire,
       * required field only for `Order.TimeInForce`.TIME_IN_FORCE_GTT`.
       */
      readonly expiresAt?: string;
      /** @description Parameters used to specify an iceberg order. */
      readonly icebergOpts?: components['schemas']['v1IcebergOpts'];
      /** @description Market ID for the order, required field. */
      readonly marketId?: string;
      /** @description Used to specify the details for a pegged order. */
      readonly peggedOrder?: components['schemas']['vegaPeggedOrder'];
      /** @description Only valid for Limit orders. Cannot be True at the same time as Reduce-Only. */
      readonly postOnly?: boolean;
      /**
       * @description Price for the order, the price is an integer, for example `123456` is a correctly
       * formatted price of `1.23456` assuming market configured to 5 decimal places,
       * required field for limit orders, however it is not required for market orders.
       * This field is an unsigned integer scaled to the market's decimal places.
       */
      readonly price?: string;
      /**
       * @description Only valid for Non-Persistent orders. Cannot be True at the same time as Post-Only.
       * If set, order will only be executed if the outcome of the trade moves the trader's position closer to 0.
       */
      readonly reduceOnly?: boolean;
      /**
       * @description Reference given for the order, this is typically used to retrieve an order submitted through consensus, currently
       * set internally by the node to return a unique reference ID for the order submission.
       */
      readonly reference?: string;
      /** @description Side for the order, e.g. SIDE_BUY or SIDE_SELL, required field. */
      readonly side?: components['schemas']['vegaSide'];
      /**
       * Format: uint64
       * @description Size for the order, for example, in a futures market the size equals the number of units, cannot be negative.
       */
      readonly size?: string;
      /** @description Time in force indicates how long an order will remain active before it is executed or expires, required field. */
      readonly timeInForce?: components['schemas']['OrderTimeInForce'];
      /** @description Type for the order, required field - See `Order.Type`. */
      readonly type?: components['schemas']['vegaOrderType'];
    };
    /** @description PropertyKey describes the property key contained in data source data. */
    readonly v1PropertyKey: {
      /** @description Name of the property. */
      readonly name?: string;
      /**
       * Optional decimal place to be be applied on the provided value
       * valid only for PropertyType of type DECIMAL and INTEGER
       * Format: uint64
       */
      readonly numberDecimalPlaces?: string;
      /** @description Data type of the property. */
      readonly type?: components['schemas']['v1PropertyKeyType'];
    };
    /**
     * @description Type describes the data type of properties that are supported by the data source
     * engine.
     *
     *  - TYPE_UNSPECIFIED: The default value.
     *  - TYPE_EMPTY: Any type.
     *  - TYPE_INTEGER: Integer type.
     *  - TYPE_STRING: String type.
     *  - TYPE_BOOLEAN: Boolean type.
     *  - TYPE_DECIMAL: Any floating point decimal type.
     *  - TYPE_TIMESTAMP: Timestamp date type.
     * @default TYPE_UNSPECIFIED
     * @enum {string}
     */
    readonly v1PropertyKeyType:
      | 'TYPE_UNSPECIFIED'
      | 'TYPE_EMPTY'
      | 'TYPE_INTEGER'
      | 'TYPE_STRING'
      | 'TYPE_BOOLEAN'
      | 'TYPE_DECIMAL'
      | 'TYPE_TIMESTAMP';
    /**
     * Command to submit a new proposal for the
     * Vega network governance
     */
    readonly v1ProposalSubmission: {
      /** @description Rationale behind a proposal. */
      readonly rationale?: components['schemas']['vegaProposalRationale'];
      /** @description Reference identifying the proposal. */
      readonly reference?: string;
      /** @description Proposal configuration and the actual change that is meant to be executed when proposal is enacted. */
      readonly terms?: components['schemas']['vegaProposalTerms'];
    };
    /** Transaction for a validator to suggest a protocol upgrade */
    readonly v1ProtocolUpgradeProposal: {
      /**
       * Format: uint64
       * @description Block height at which to perform the upgrade.
       */
      readonly upgradeBlockHeight?: string;
      /** @description Release tag for the Vega binary. */
      readonly vegaReleaseTag?: string;
    };
    /**
     * @description PubKey is the public key that signed this data.
     * Different public keys coming from different sources will be further separated.
     */
    readonly v1PubKey: {
      readonly key?: string;
    };
    /**
     * @description Signature to authenticate a transaction and to be verified by the Vega
     * network.
     */
    readonly v1Signature: {
      /** @description Algorithm used to create the signature. */
      readonly algo?: string;
      /** @description Hex encoded bytes of the signature. */
      readonly value?: string;
      /**
       * Format: int64
       * @description Version of the signature used to create the signature.
       */
      readonly version?: number;
    };
    readonly v1Signer: {
      /** @description In case of an open oracle - Ethereum address will be submitted. */
      readonly ethAddress?: components['schemas']['v1ETHAddress'];
      /**
       * @description List of authorized public keys that signed the data for this
       * source. All the public keys in the data should be contained in these
       * public keys.
       */
      readonly pubKey?: components['schemas']['v1PubKey'];
    };
    /** Transaction for a validator to submit a floating point value */
    readonly v1StateVariableProposal: {
      /** @description State value proposal details. */
      readonly proposal?: components['schemas']['vegaStateValueProposal'];
    };
    /** Price and expiry configuration for a stop order */
    readonly v1StopOrderSetup: {
      /**
       * Format: int64
       * @description Optional expiry timestamp.
       */
      readonly expiresAt?: string;
      /** @description Strategy to adopt if the expiry time is reached. */
      readonly expiryStrategy?: components['schemas']['StopOrderExpiryStrategy'];
      /** @description Order to be submitted once the trigger is breached. */
      readonly orderSubmission?: components['schemas']['v1OrderSubmission'];
      /** @description Fixed price at which the order will be submitted. */
      readonly price?: string;
      /** @description Trailing percentage at which the order will be submitted. */
      readonly trailingPercentOffset?: string;
    };
    /**
     * Cancel a stop order.
     * The following combinations are available:
     * Empty object will cancel all stop orders for the party
     * Market ID alone will cancel all stop orders in a market
     * Market ID and order ID will cancel a specific stop order in a market
     * If the stop order is part of an OCO, both stop orders will be cancelled
     */
    readonly v1StopOrdersCancellation: {
      /** @description Optional market ID. */
      readonly marketId?: string;
      /** @description Optional order ID. */
      readonly stopOrderId?: string;
    };
    /**
     * Stop order submission submits stops orders.
     * It is possible to make a single stop order submission by
     * specifying a single direction,
     * or an OCO (One Cancels the Other) stop order submission
     * by specifying a configuration for both directions
     */
    readonly v1StopOrdersSubmission: {
      /**
       * @description Stop order that will be triggered
       * if the price falls below a given trigger price.
       */
      readonly fallsBelow?: components['schemas']['v1StopOrderSetup'];
      /**
       * @description Stop order that will be triggered
       * if the price rises above a given trigger price.
       */
      readonly risesAbove?: components['schemas']['v1StopOrderSetup'];
    };
    readonly v1UndelegateSubmission: {
      /**
       * @description Optional, if not specified = ALL.
       * If provided, this field must be an unsigned integer passed as a string
       * and needs to be scaled using the asset decimal places for the token.
       */
      readonly amount?: string;
      /** @description Method of delegation. */
      readonly method?: components['schemas']['UndelegateSubmissionMethod'];
      /** @description Node ID to delegate to. */
      readonly nodeId?: string;
    };
    /**
     * Message from a validator signalling they are still online and validating blocks
     * or ready to validate blocks when they are still a pending validator
     */
    readonly v1ValidatorHeartbeat: {
      /** @description Signature from the validator made using the ethereum wallet. */
      readonly ethereumSignature?: components['schemas']['v1Signature'];
      /** @description Message which has been signed. */
      readonly message?: string;
      /** @description Node ID of the validator emitting the heartbeat. */
      readonly nodeId?: string;
      /** @description Signature from the validator made using the vega wallet. */
      readonly vegaSignature?: components['schemas']['v1Signature'];
    };
    /** @description Command to submit a new vote for a governance proposal. */
    readonly v1VoteSubmission: {
      /** @description Submit vote for the specified proposal ID. */
      readonly proposalId?: string;
      /** @description Actual value of the vote. */
      readonly value?: components['schemas']['vegaVoteValue'];
    };
    /** Represents the submission request to withdraw funds for a party on Vega */
    readonly v1WithdrawSubmission: {
      /** @description Amount to be withdrawn. This field is an unsigned integer scaled to the asset's decimal places. */
      readonly amount?: string;
      /** @description Asset to be withdrawn. */
      readonly asset?: string;
      /** @description Foreign chain specifics. */
      readonly ext?: components['schemas']['vegaWithdrawExt'];
    };
    /**
     * Various collateral/account types as used by Vega
     * @description - ACCOUNT_TYPE_UNSPECIFIED: Default value
     *  - ACCOUNT_TYPE_INSURANCE: Insurance pool accounts contain insurance pool funds for a market
     *  - ACCOUNT_TYPE_SETTLEMENT: Settlement accounts exist only during settlement or mark-to-market
     *  - ACCOUNT_TYPE_MARGIN: Margin accounts contain funds set aside for the margin needed to support a party's open positions.
     * Each party will have a margin account for each market they have traded in.
     * Required initial margin is allocated to each market from user's general account.
     * Collateral in the margin account can't be withdrawn or used as margin on another market until
     * it is released back to the general account.
     * Vega protocol uses an internal accounting system to segregate funds held as
     * margin from other funds to ensure they are never lost or 'double spent'
     *
     * Margin account funds will vary as margin requirements on positions change
     *  - ACCOUNT_TYPE_GENERAL: General accounts contain the collateral for a party that is not otherwise allocated. A party will
     * have multiple general accounts, one for each asset they want
     * to trade with
     *
     * General accounts are where funds are initially deposited or withdrawn from,
     * it is also the account where funds are taken to fulfil fees and initial margin requirements
     *  - ACCOUNT_TYPE_FEES_INFRASTRUCTURE: Infrastructure accounts contain fees earned by providing infrastructure on Vega
     *  - ACCOUNT_TYPE_FEES_LIQUIDITY: Liquidity accounts contain fees earned by providing liquidity on Vega markets
     *  - ACCOUNT_TYPE_FEES_MAKER: This account is created to hold fees earned by placing orders that sit on the book
     * and are then matched with an incoming order to create a trade - These fees reward parties
     * who provide the best priced liquidity that actually allows trading to take place
     *  - ACCOUNT_TYPE_BOND: This account is created to maintain liquidity providers funds commitments
     *  - ACCOUNT_TYPE_EXTERNAL: External account represents an external source (deposit/withdrawal)
     *  - ACCOUNT_TYPE_GLOBAL_INSURANCE: Global insurance account for the asset
     *  - ACCOUNT_TYPE_GLOBAL_REWARD: Global reward account for the asset
     *  - ACCOUNT_TYPE_PENDING_TRANSFERS: Per asset account used to store pending transfers (if any)
     *  - ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES: Per asset reward account for fees paid to makers
     *  - ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES: Per asset reward account for fees received by makers
     *  - ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES: Per asset reward account for fees received by liquidity providers
     *  - ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS: Per asset reward account for market proposers when the market goes above some trading threshold
     *  - ACCOUNT_TYPE_HOLDING: Per asset account for holding in-flight unfilled orders' funds
     * @default ACCOUNT_TYPE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaAccountType:
      | 'ACCOUNT_TYPE_UNSPECIFIED'
      | 'ACCOUNT_TYPE_INSURANCE'
      | 'ACCOUNT_TYPE_SETTLEMENT'
      | 'ACCOUNT_TYPE_MARGIN'
      | 'ACCOUNT_TYPE_GENERAL'
      | 'ACCOUNT_TYPE_FEES_INFRASTRUCTURE'
      | 'ACCOUNT_TYPE_FEES_LIQUIDITY'
      | 'ACCOUNT_TYPE_FEES_MAKER'
      | 'ACCOUNT_TYPE_BOND'
      | 'ACCOUNT_TYPE_EXTERNAL'
      | 'ACCOUNT_TYPE_GLOBAL_INSURANCE'
      | 'ACCOUNT_TYPE_GLOBAL_REWARD'
      | 'ACCOUNT_TYPE_PENDING_TRANSFERS'
      | 'ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES'
      | 'ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES'
      | 'ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES'
      | 'ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS'
      | 'ACCOUNT_TYPE_HOLDING';
    /** Vega representation of an external asset */
    readonly vegaAssetDetails: {
      /** @description Vega built-in asset. */
      readonly builtinAsset?: components['schemas']['vegaBuiltinAsset'];
      /**
       * Format: uint64
       * @description Number of decimal / precision handled by this asset.
       */
      readonly decimals?: string;
      /** @description Ethereum ERC20 asset. */
      readonly erc20?: components['schemas']['vegaERC20'];
      /** @description Name of the asset (e.g: Great British Pound). */
      readonly name?: string;
      /** @description Minimum economically meaningful amount in the asset. */
      readonly quantum?: string;
      /** @description Symbol of the asset (e.g: GBP). */
      readonly symbol?: string;
    };
    /** @description Changes to apply on an existing asset. */
    readonly vegaAssetDetailsUpdate: {
      /** @description Ethereum ERC20 asset update. */
      readonly erc20?: components['schemas']['vegaERC20Update'];
      /** @description Minimum economically meaningful amount in the asset. */
      readonly quantum?: string;
    };
    /** Vega internal asset */
    readonly vegaBuiltinAsset: {
      /** @description Maximum amount that can be requested by a party through the built-in asset faucet at a time. */
      readonly maxFaucetAmountMint?: string;
    };
    /** Deposit for a Vega built-in asset */
    readonly vegaBuiltinAssetDeposit: {
      /** @description Amount to be deposited. This field is an unsigned integer scaled to the asset's decimal places. */
      readonly amount?: string;
      /** @description Vega party ID i.e. public key. */
      readonly partyId?: string;
      /** @description Vega network internal asset ID. */
      readonly vegaAssetId?: string;
    };
    /** Event related to a Vega built-in asset */
    readonly vegaBuiltinAssetEvent: {
      /** @description Built-in asset deposit. */
      readonly deposit?: components['schemas']['vegaBuiltinAssetDeposit'];
      /** @description Built-in asset withdrawal. */
      readonly withdrawal?: components['schemas']['vegaBuiltinAssetWithdrawal'];
    };
    /** Withdrawal for a Vega built-in asset */
    readonly vegaBuiltinAssetWithdrawal: {
      /** @description The amount to be withdrawn. This field is an unsigned integer scaled to the asset's decimal places. */
      readonly amount?: string;
      /** @description Vega network party ID i.e. public key. */
      readonly partyId?: string;
      /** @description Vega network internal asset ID. */
      readonly vegaAssetId?: string;
    };
    readonly vegaCancelTransfer: {
      /** Configuration for cancellation of a governance-initiated transfer */
      readonly changes?: components['schemas']['vegaCancelTransferConfiguration'];
    };
    readonly vegaCancelTransferConfiguration: {
      /** @description ID of the governance transfer proposal. */
      readonly transferId?: string;
    };
    /**
     * @description DataSourceDefinition represents the top level object that deals with data sources.
     * DataSourceDefinition can be external or internal, with whatever number of data sources are defined
     * for each type in the child objects below.
     */
    readonly vegaDataSourceDefinition: {
      readonly external?: components['schemas']['vegaDataSourceDefinitionExternal'];
      readonly internal?: components['schemas']['vegaDataSourceDefinitionInternal'];
    };
    /**
     * @description DataSourceDefinitionExternal is the top level object used for all external data sources.
     * It contains one of any of the defined `SourceType` variants.
     */
    readonly vegaDataSourceDefinitionExternal: {
      readonly ethCall?: components['schemas']['vegaEthCallSpec'];
      readonly oracle?: components['schemas']['vegaDataSourceSpecConfiguration'];
    };
    /**
     * @description DataSourceDefinitionInternal is the top level object used for all internal data sources.
     * It contains one of any of the defined `SourceType` variants.
     */
    readonly vegaDataSourceDefinitionInternal: {
      readonly time?: components['schemas']['vegaDataSourceSpecConfigurationTime'];
    };
    /**
     * @description All types of external data sources use the same configuration set for meeting requirements
     * in order for the data to be useful for Vega - valid signatures and matching filters.
     */
    readonly vegaDataSourceSpecConfiguration: {
      /**
       * @description Filters describes which source data are considered of interest or not for
       * the product (or the risk model).
       */
      readonly filters?: readonly components['schemas']['v1Filter'][];
      /**
       * @description Signers is the list of authorized signatures that signed the data for this
       * source. All the signatures in the data source data should be contained in this
       * external source. All the signatures in the data should be contained in this list.
       */
      readonly signers?: readonly components['schemas']['v1Signer'][];
    };
    /** @description DataSourceSpecConfigurationTime is the internal data source used for emitting timestamps. */
    readonly vegaDataSourceSpecConfigurationTime: {
      /** @description Conditions that the timestamps should meet in order to be considered. */
      readonly conditions?: readonly components['schemas']['v1Condition'][];
    };
    /**
     * DataSourceSpecToFutureBinding describes which property of the data source data is to be
     * used as settlement data and which to use as the trading terminated trigger
     */
    readonly vegaDataSourceSpecToFutureBinding: {
      /**
       * @description Name of the property in the source data that should be used as settlement data.
       * If it is set to "prices.BTC.value", then the Future will use the value of
       * this property as settlement data.
       */
      readonly settlementDataProperty?: string;
      /** @description Name of the property in the data source data that signals termination of trading. */
      readonly tradingTerminationProperty?: string;
    };
    /**
     * - DISPATCH_METRIC_MAKER_FEES_PAID: Dispatch metric that is using the total maker fees paid in the market
     *  - DISPATCH_METRIC_MAKER_FEES_RECEIVED: Dispatch metric that is using the total maker fees received in the market
     *  - DISPATCH_METRIC_LP_FEES_RECEIVED: Dispatch metric that is using the total LP fees received in the market
     *  - DISPATCH_METRIC_MARKET_VALUE: Dispatch metric that is using total value of the market if above the required threshold and not paid given proposer bonus yet
     * @default DISPATCH_METRIC_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaDispatchMetric:
      | 'DISPATCH_METRIC_UNSPECIFIED'
      | 'DISPATCH_METRIC_MAKER_FEES_PAID'
      | 'DISPATCH_METRIC_MAKER_FEES_RECEIVED'
      | 'DISPATCH_METRIC_LP_FEES_RECEIVED'
      | 'DISPATCH_METRIC_MARKET_VALUE';
    readonly vegaDispatchStrategy: {
      /** @description Asset to use for metric. */
      readonly assetForMetric?: string;
      /** @description Optional markets in scope. */
      readonly markets?: readonly string[];
      /** @description Metric to apply. */
      readonly metric?: components['schemas']['vegaDispatchMetric'];
    };
    /** ERC20 token based asset, living on the ethereum network */
    readonly vegaERC20: {
      /** @description Address of the contract for the token, on the ethereum network. */
      readonly contractAddress?: string;
      /**
       * @description Lifetime limits deposit per address
       * note: this is a temporary measure that can be changed by governance.
       */
      readonly lifetimeLimit?: string;
      /**
       * @description Maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.
       * Theres no limit on the size of a withdrawal
       * note: this is a temporary measure that can be changed by governance.
       */
      readonly withdrawThreshold?: string;
    };
    /** Asset deny-listing for an ERC20 token */
    readonly vegaERC20AssetDelist: {
      /** @description Vega network internal asset ID. */
      readonly vegaAssetId?: string;
    };
    readonly vegaERC20AssetLimitsUpdated: {
      /** @description Updated lifetime limits. */
      readonly lifetimeLimits?: string;
      /** @description Ethereum wallet that initiated the deposit. */
      readonly sourceEthereumAddress?: string;
      /** @description Vega network internal asset ID. */
      readonly vegaAssetId?: string;
      /** @description Updated withdrawal threshold. */
      readonly withdrawThreshold?: string;
    };
    /** Asset allow-listing for an ERC20 token */
    readonly vegaERC20AssetList: {
      /** @description Ethereum address of the asset. */
      readonly assetSource?: string;
      /** @description Vega network internal asset ID. */
      readonly vegaAssetId?: string;
    };
    /** Asset deposit for an ERC20 token */
    readonly vegaERC20Deposit: {
      /** @description Amount to be deposited. */
      readonly amount?: string;
      /** @description Ethereum wallet that initiated the deposit. */
      readonly sourceEthereumAddress?: string;
      /** @description Vega party ID i.e. public key that is the target of the deposit. */
      readonly targetPartyId?: string;
      /** @description Vega network internal asset ID. */
      readonly vegaAssetId?: string;
    };
    /** Event related to an ERC20 token */
    readonly vegaERC20Event: {
      /** @description De-list an ERC20 asset. */
      readonly assetDelist?: components['schemas']['vegaERC20AssetDelist'];
      /** @description Update an ERC20 asset. */
      readonly assetLimitsUpdated?: components['schemas']['vegaERC20AssetLimitsUpdated'];
      /** @description List an ERC20 asset. */
      readonly assetList?: components['schemas']['vegaERC20AssetList'];
      /**
       * Format: uint64
       * @description Block in which the transaction was added.
       */
      readonly block?: string;
      /** @description Bridge operations has been resumed. */
      readonly bridgeResumed?: boolean;
      /** @description Bridge operations has been stopped. */
      readonly bridgeStopped?: boolean;
      /** @description Deposit ERC20 asset. */
      readonly deposit?: components['schemas']['vegaERC20Deposit'];
      /**
       * Format: uint64
       * @description Index of the log in the transaction.
       */
      readonly index?: string;
      /** @description Withdraw ERC20 asset. */
      readonly withdrawal?: components['schemas']['vegaERC20Withdrawal'];
    };
    /** Event related to the ERC20 MultiSig */
    readonly vegaERC20MultiSigEvent: {
      /**
       * Block in which the transaction was added
       * Format: uint64
       */
      readonly block?: string;
      /**
       * Index of the log in the transaction
       * Format: uint64
       */
      readonly index?: string;
      /** Add a signer to the erc20 bridge */
      readonly signerAdded?: components['schemas']['vegaERC20SignerAdded'];
      /** Remove a signer from the erc20 bridge */
      readonly signerRemoved?: components['schemas']['vegaERC20SignerRemoved'];
      /** Threshold set */
      readonly thresholdSet?: components['schemas']['vegaERC20ThresholdSet'];
    };
    /** New signer added to the ERC20 bridge */
    readonly vegaERC20SignerAdded: {
      /**
       * Format: int64
       * @description Time at which the block was produced
       * will be used to inform the core at what time
       * the stake was made unavailable.
       */
      readonly blockTime?: string;
      /** Ethereum address of the new signer */
      readonly newSigner?: string;
      /** Nonce created by the Vega network used for this new signer */
      readonly nonce?: string;
    };
    /** Signer removed from the ERC20 bridge */
    readonly vegaERC20SignerRemoved: {
      /**
       * Format: int64
       * @description Time at which the block was produced.
       * Will be used to inform the core at what time
       * the stake was made unavailable.
       */
      readonly blockTime?: string;
      /** Nonce created by the Vega network used for this old signer */
      readonly nonce?: string;
      /** Ethereum address of the old signer */
      readonly oldSigner?: string;
    };
    /** Threshold has been updated on the multisig control */
    readonly vegaERC20ThresholdSet: {
      /**
       * Format: int64
       * @description Time at which the block was produced.
       * Will be used to inform the core at what time
       * the stake was made unavailable.
       */
      readonly blockTime?: string;
      /**
       * New threshold value to set
       * Format: int64
       */
      readonly newThreshold?: number;
      /** Nonce created by the Vega network */
      readonly nonce?: string;
    };
    readonly vegaERC20Update: {
      /**
       * @description Lifetime limits deposit per address.
       * This will be interpreted against the asset decimals.
       * note: this is a temporary measure that can be changed by governance.
       */
      readonly lifetimeLimit?: string;
      /**
       * @description Maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.
       * Theres no limit on the size of a withdrawal
       * note: this is a temporary measure that can be changed by governance.
       */
      readonly withdrawThreshold?: string;
    };
    /** Asset withdrawal for an ERC20 token */
    readonly vegaERC20Withdrawal: {
      /** @description Reference nonce used for the transaction. */
      readonly referenceNonce?: string;
      /** @description Target Ethereum wallet address. */
      readonly targetEthereumAddress?: string;
      /** @description Vega network internal asset ID. */
      readonly vegaAssetId?: string;
    };
    /** Extension of data required for the withdraw submissions */
    readonly vegaErc20WithdrawExt: {
      /** @description Address into which the bridge will release the funds. */
      readonly receiverAddress?: string;
    };
    /** @description Specifies a data source that derives its content from calling a read method on an Ethereum contract. */
    readonly vegaEthCallSpec: {
      /** @description The ABI of that contract. */
      readonly abi?: readonly Record<string, never>[];
      /** @description Ethereum address of the contract to call. */
      readonly address?: string;
      /**
       * @description List of arguments to pass to method call.
       * Protobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum type according to the ABI.
       */
      readonly args?: readonly Record<string, never>[];
      /** @description Name of the method on the contract to call. */
      readonly method?: string;
      /** @description Conditions for determining when to call the contract method. */
      readonly trigger?: components['schemas']['vegaEthCallTrigger'];
    };
    /** @description Determines when the contract method should be called. */
    readonly vegaEthCallTrigger: {
      readonly timeTrigger?: components['schemas']['vegaEthTimeTrigger'];
    };
    /** Result of calling an arbitrary Ethereum contract method */
    readonly vegaEthContractCallEvent: {
      /**
       * Format: uint64
       * @description Ethereum block height.
       */
      readonly blockHeight?: string;
      /**
       * Format: uint64
       * @description Ethereum block time in Unix seconds.
       */
      readonly blockTime?: string;
      /**
       * Format: byte
       * @description Result of contract call, packed according to the ABI stored in the associated data source spec.
       */
      readonly result?: string;
      /** @description ID of the data source spec that triggered this contract call. */
      readonly specId?: string;
    };
    /** @description Trigger for an Ethereum call based on the Ethereum block timestamp. Can be one-off or repeating. */
    readonly vegaEthTimeTrigger: {
      /**
       * Format: uint64
       * @description Repeat the call every n seconds after the inital call. If no time for initial call was specified, begin repeating immediately.
       */
      readonly every?: string;
      /**
       * Format: uint64
       * @description Trigger when the Ethereum time is greater or equal to this time, in Unix seconds.
       */
      readonly initial?: string;
      /**
       * Format: uint64
       * @description If repeating, stop once Ethereum time is greater than this time, in Unix seconds. If not set, then repeat indefinitely.
       */
      readonly until?: string;
    };
    /** Future product configuration */
    readonly vegaFutureProduct: {
      /** @description Binding between the data source spec and the settlement data. */
      readonly dataSourceSpecBinding?: components['schemas']['vegaDataSourceSpecToFutureBinding'];
      /** @description Data source spec describing the data source for settlement. */
      readonly dataSourceSpecForSettlementData?: components['schemas']['vegaDataSourceDefinition'];
      /** @description The external data source spec describing the data source of trading termination. */
      readonly dataSourceSpecForTradingTermination?: components['schemas']['vegaDataSourceDefinition'];
      /** @description Product quote name. */
      readonly quoteName?: string;
      /** @description Asset ID for the product's settlement asset. */
      readonly settlementAsset?: string;
    };
    /**
     * @default GOVERNANCE_TRANSFER_TYPE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaGovernanceTransferType:
      | 'GOVERNANCE_TRANSFER_TYPE_UNSPECIFIED'
      | 'GOVERNANCE_TRANSFER_TYPE_ALL_OR_NOTHING'
      | 'GOVERNANCE_TRANSFER_TYPE_BEST_EFFORT';
    /** Instrument configuration */
    readonly vegaInstrumentConfiguration: {
      /** @description Instrument code, human-readable shortcode used to describe the instrument. */
      readonly code?: string;
      /** @description Future. */
      readonly future?: components['schemas']['vegaFutureProduct'];
      /** @description Instrument name. */
      readonly name?: string;
      /** @description Spot. */
      readonly spot?: components['schemas']['vegaSpotProduct'];
    };
    readonly vegaKeyValueBundle: {
      readonly key?: string;
      readonly tolerance?: string;
      readonly value?: components['schemas']['vegaStateVarValue'];
    };
    /** LiquidityMonitoringParameters contains settings used for liquidity monitoring */
    readonly vegaLiquidityMonitoringParameters: {
      /**
       * Format: int64
       * @description Specifies by how many seconds an auction should be extended if leaving the auction were to trigger a liquidity auction.
       */
      readonly auctionExtension?: string;
      /** @description Specifies parameters related to target stake calculation. */
      readonly targetStakeParameters?: components['schemas']['vegaTargetStakeParameters'];
      /** @description Specifies the triggering ratio for entering liquidity auction. */
      readonly triggeringRatio?: string;
    };
    /** Represents a liquidity order */
    readonly vegaLiquidityOrder: {
      /** @description Offset/amount of units away for the order. This field is an unsigned integer scaled using the market's decimal places. */
      readonly offset?: string;
      /**
       * Format: int64
       * @description Relative proportion of the commitment to be allocated at a price level.
       */
      readonly proportion?: number;
      /** @description Pegged reference point for the order. */
      readonly reference?: components['schemas']['vegaPeggedReference'];
    };
    /** Risk model parameters for log normal */
    readonly vegaLogNormalModelParams: {
      /**
       * Format: double
       * @description Mu parameter, annualised growth rate of the underlying asset.
       */
      readonly mu?: number;
      /**
       * Format: double
       * @description R parameter, annualised growth rate of the risk-free asset, used for discounting of future cash flows, can be any real number.
       */
      readonly r?: number;
      /**
       * Format: double
       * @description Sigma parameter, annualised volatility of the underlying asset, must be a strictly non-negative real number.
       */
      readonly sigma?: number;
    };
    /** Risk model for log normal */
    readonly vegaLogNormalRiskModel: {
      /** @description Risk model parameters for log normal. */
      readonly params?: components['schemas']['vegaLogNormalModelParams'];
      /**
       * Format: double
       * @description Risk Aversion Parameter.
       */
      readonly riskAversionParameter?: number;
      /**
       * Format: double
       * @description Tau parameter of the risk model, projection horizon measured as a year fraction used in the expected shortfall
       * calculation to obtain the maintenance margin, must be a strictly non-negative real number.
       */
      readonly tau?: number;
    };
    readonly vegaMatrixValue: {
      readonly value?: readonly components['schemas']['vegaVectorValue'][];
    };
    /** Represents a network parameter on Vega */
    readonly vegaNetworkParameter: {
      /** @description Unique key of the network parameter. */
      readonly key?: string;
      /** @description Value for the network parameter. */
      readonly value?: string;
    };
    /** New asset on Vega */
    readonly vegaNewAsset: {
      /** @description Configuration of the new asset. */
      readonly changes?: components['schemas']['vegaAssetDetails'];
    };
    /**
     * @description Freeform proposal
     * This message is just used as a placeholder to sort out the nature of the
     * proposal once parsed.
     */
    readonly vegaNewFreeform: Record<string, never>;
    /** New market on Vega */
    readonly vegaNewMarket: {
      /** @description Configuration of the new market. */
      readonly changes?: components['schemas']['vegaNewMarketConfiguration'];
    };
    /** Configuration for a new futures market on Vega */
    readonly vegaNewMarketConfiguration: {
      /**
       * Format: uint64
       * @description Decimal places used for the new futures market, sets the smallest price increment on the book.
       */
      readonly decimalPlaces?: string;
      /** @description New futures market instrument configuration. */
      readonly instrument?: components['schemas']['vegaInstrumentConfiguration'];
      /** @description Linear slippage factor is used to cap the slippage component of maintenance margin - it is applied to the slippage volume. */
      readonly linearSlippageFactor?: string;
      /** @description Liquidity monitoring parameters. */
      readonly liquidityMonitoringParameters?: components['schemas']['vegaLiquidityMonitoringParameters'];
      /** @description Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected. */
      readonly logNormal?: components['schemas']['vegaLogNormalRiskModel'];
      /**
       * @description Percentage move up and down from the mid price which specifies the range of
       * price levels over which automated liquidity provision orders will be deployed.
       */
      readonly lpPriceRange?: string;
      /** @description Optional new futures market metadata, tags. */
      readonly metadata?: readonly string[];
      /**
       * Format: int64
       * @description Decimal places for order sizes, sets what size the smallest order / position on the futures market can be.
       */
      readonly positionDecimalPlaces?: string;
      /** @description Price monitoring parameters. */
      readonly priceMonitoringParameters?: components['schemas']['vegaPriceMonitoringParameters'];
      /** @description Quadratic slippage factor is used to cap the slippage component of maintenance margin - it is applied to the square of the slippage volume. */
      readonly quadraticSlippageFactor?: string;
      /** @description Simple risk model parameters, valid only if MODEL_SIMPLE is selected. */
      readonly simple?: components['schemas']['vegaSimpleModelParams'];
      /** @description Successor configuration. If this proposal is meant to succeed a given market, then this should be set. */
      readonly successor?: components['schemas']['vegaSuccessorConfiguration'];
    };
    /** New spot market on Vega */
    readonly vegaNewSpotMarket: {
      /** @description Configuration of the new spot market. */
      readonly changes?: components['schemas']['vegaNewSpotMarketConfiguration'];
    };
    /** Configuration for a new spot market on Vega */
    readonly vegaNewSpotMarketConfiguration: {
      /**
       * Format: uint64
       * @description Decimal places used for the new spot market, sets the smallest price increment on the book.
       */
      readonly decimalPlaces?: string;
      /** @description New spot market instrument configuration. */
      readonly instrument?: components['schemas']['vegaInstrumentConfiguration'];
      /** @description Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected. */
      readonly logNormal?: components['schemas']['vegaLogNormalRiskModel'];
      /** @description Optional new spot market metadata, tags. */
      readonly metadata?: readonly string[];
      /**
       * Format: int64
       * @description Decimal places for order sizes, sets what size the smallest order / position on the spot market can be.
       */
      readonly positionDecimalPlaces?: string;
      /** @description Price monitoring parameters. */
      readonly priceMonitoringParameters?: components['schemas']['vegaPriceMonitoringParameters'];
      /** @description Simple risk model parameters, valid only if MODEL_SIMPLE is selected. */
      readonly simple?: components['schemas']['vegaSimpleModelParams'];
      /** @description Specifies parameters related to target stake calculation. */
      readonly targetStakeParameters?: components['schemas']['vegaTargetStakeParameters'];
    };
    /** New governance transfer */
    readonly vegaNewTransfer: {
      /** @description Configuration for a new transfer. */
      readonly changes?: components['schemas']['vegaNewTransferConfiguration'];
    };
    readonly vegaNewTransferConfiguration: {
      /** Maximum amount to transfer */
      readonly amount?: string;
      /** ID of asset to transfer */
      readonly asset?: string;
      /**
       * Specifies the account to transfer to, depending on the account type:
       * Network treasury: leave empty
       * Party: party's public key
       * Market insurance pool: market ID
       */
      readonly destination?: string;
      /** Specifies the account type to transfer to: reward pool, party, network insurance pool, market insurance pool */
      readonly destinationType?: components['schemas']['vegaAccountType'];
      /** Maximum fraction of the source account's balance to transfer as a decimal - i.e. 0.1 = 10% of the balance */
      readonly fractionOfBalance?: string;
      readonly oneOff?: components['schemas']['vegaOneOffTransfer'];
      readonly recurring?: components['schemas']['vegaRecurringTransfer'];
      /** If network treasury, field is empty, otherwise uses the market ID */
      readonly source?: string;
      /** Source account type, such as network treasury, market insurance pool */
      readonly sourceType?: components['schemas']['vegaAccountType'];
      /**
       * "All or nothing" or "best effort":
       * All or nothing: Transfers the specified amount or does not transfer anything
       * Best effort: Transfers the specified amount or the max allowable amount if this is less than the specified amount
       */
      readonly transferType?: components['schemas']['vegaGovernanceTransferType'];
    };
    /** Specific details for a one off transfer */
    readonly vegaOneOffTransfer: {
      /**
       * Format: int64
       * @description Timestamp in Unix nanoseconds for when the transfer should be delivered into the receiver's account.
       */
      readonly deliverOn?: string;
    };
    /**
     * Type values for an order
     * @description - TYPE_UNSPECIFIED: Default value, always invalid
     *  - TYPE_LIMIT: Used for Limit orders
     *  - TYPE_MARKET: Used for Market orders
     *  - TYPE_NETWORK: Used for orders where the initiating party is the network (with distressed parties)
     * @default TYPE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaOrderType:
      | 'TYPE_UNSPECIFIED'
      | 'TYPE_LIMIT'
      | 'TYPE_MARKET'
      | 'TYPE_NETWORK';
    /**
     * Pegged orders are limit orders where the price is specified in the form REFERENCE +/- OFFSET
     * They can be used for any limit order that is valid during continuous trading
     */
    readonly vegaPeggedOrder: {
      /** @description Offset from the price reference. */
      readonly offset?: string;
      /** @description Price point the order is linked to. */
      readonly reference?: components['schemas']['vegaPeggedReference'];
    };
    /**
     * Pegged reference defines which price point a pegged order is linked to - meaning
     * the price for a pegged order is calculated from the value of the reference price point
     * @description - PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given
     *  - PEGGED_REFERENCE_MID: Mid price reference
     *  - PEGGED_REFERENCE_BEST_BID: Best bid price reference
     *  - PEGGED_REFERENCE_BEST_ASK: Best ask price reference
     * @default PEGGED_REFERENCE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaPeggedReference:
      | 'PEGGED_REFERENCE_UNSPECIFIED'
      | 'PEGGED_REFERENCE_MID'
      | 'PEGGED_REFERENCE_BEST_BID'
      | 'PEGGED_REFERENCE_BEST_ASK';
    /** PriceMonitoringParameters contains a collection of triggers to be used for a given market */
    readonly vegaPriceMonitoringParameters: {
      readonly triggers?: readonly components['schemas']['vegaPriceMonitoringTrigger'][];
    };
    /** PriceMonitoringTrigger holds together price projection horizon , probability level p, and auction extension duration */
    readonly vegaPriceMonitoringTrigger: {
      /**
       * Format: int64
       * @description Price monitoring auction extension duration in seconds should the price
       * breach its theoretical level over the specified horizon at the specified
       * probability level.
       */
      readonly auctionExtension?: string;
      /**
       * Format: int64
       * @description Price monitoring projection horizon  in seconds.
       */
      readonly horizon?: string;
      /** @description Price monitoring probability level p. */
      readonly probability?: string;
    };
    /** @description Rationale behind a proposal. */
    readonly vegaProposalRationale: {
      /**
       * @description Description to show a short title / something in case the link goes offline.
       * This is to be between 0 and 20k unicode characters.
       * This is mandatory for all proposals.
       */
      readonly description?: string;
      /**
       * @description Title to be used to give a short description of the proposal in lists.
       * This is to be between 0 and 100 unicode characters.
       * This is mandatory for all proposals.
       */
      readonly title?: string;
    };
    /** Terms for a governance proposal on Vega */
    readonly vegaProposalTerms: {
      /** @description Cancel a governance transfer. */
      readonly cancelTransfer?: components['schemas']['vegaCancelTransfer'];
      /**
       * Format: int64
       * @description Timestamp as Unix time in seconds when voting closes for this proposal,
       * constrained by `minClose` and `maxClose` network parameters.
       */
      readonly closingTimestamp?: string;
      /**
       * Format: int64
       * @description Timestamp as Unix time in seconds when proposal gets enacted if passed,
       * constrained by `minEnact` and `maxEnact` network parameters.
       */
      readonly enactmentTimestamp?: string;
      /** @description Proposal change for creating new assets on Vega. */
      readonly newAsset?: components['schemas']['vegaNewAsset'];
      /**
       * @description Proposal change for a freeform request, which can be voted on but does not change the behaviour of the system,
       * and can be used to gauge community sentiment.
       */
      readonly newFreeform?: components['schemas']['vegaNewFreeform'];
      /** @description Proposal change for creating new futures market on Vega. */
      readonly newMarket?: components['schemas']['vegaNewMarket'];
      /** @description Proposal change for creating new spot market on Vega. */
      readonly newSpotMarket?: components['schemas']['vegaNewSpotMarket'];
      /** @description Proposal change for a governance transfer. */
      readonly newTransfer?: components['schemas']['vegaNewTransfer'];
      /** @description Proposal change for updating an asset. */
      readonly updateAsset?: components['schemas']['vegaUpdateAsset'];
      /** @description Proposal change for modifying an existing futures market on Vega. */
      readonly updateMarket?: components['schemas']['vegaUpdateMarket'];
      /** @description Proposal change for updating Vega network parameters. */
      readonly updateNetworkParameter?: components['schemas']['vegaUpdateNetworkParameter'];
      /** @description Proposal change for modifying an existing spot market on Vega. */
      readonly updateSpotMarket?: components['schemas']['vegaUpdateSpotMarket'];
      /**
       * Format: int64
       * @description Validation timestamp as Unix time in seconds.
       */
      readonly validationTimestamp?: string;
    };
    /** Specific details for a recurring transfer */
    readonly vegaRecurringTransfer: {
      /**
       * Format: uint64
       * @description Last epoch at which this transfer shall be paid.
       */
      readonly endEpoch?: string;
      /**
       * Format: uint64
       * @description First epoch from which this transfer shall be paid.
       */
      readonly startEpoch?: string;
    };
    readonly vegaScalarValue: {
      readonly value?: string;
    };
    /**
     * Side relates to the direction of an order, to Buy, or Sell
     * @description - SIDE_UNSPECIFIED: Default value, always invalid
     *  - SIDE_BUY: Buy order
     *  - SIDE_SELL: Sell order
     * @default SIDE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaSide: 'SIDE_UNSPECIFIED' | 'SIDE_BUY' | 'SIDE_SELL';
    /** Risk model parameters for simple modelling */
    readonly vegaSimpleModelParams: {
      /**
       * Format: double
       * @description Pre-defined risk factor value for long.
       */
      readonly factorLong?: number;
      /**
       * Format: double
       * @description Pre-defined risk factor value for short.
       */
      readonly factorShort?: number;
      /**
       * Format: double
       * @description Pre-defined maximum price move up that the model considers as valid.
       */
      readonly maxMoveUp?: number;
      /**
       * Format: double
       * @description Pre-defined minimum price move down that the model considers as valid.
       */
      readonly minMoveDown?: number;
      /**
       * Format: double
       * @description Pre-defined constant probability of trading.
       */
      readonly probabilityOfTrading?: number;
    };
    /** Spot product configuration */
    readonly vegaSpotProduct: {
      /** @description Base asset ID. */
      readonly baseAsset?: string;
      /** @description Product name. */
      readonly name?: string;
      /** @description Quote asset ID. */
      readonly quoteAsset?: string;
    };
    readonly vegaStakeDeposited: {
      /** @description Amount deposited as an unsigned base 10 integer scaled to the asset's decimal places. */
      readonly amount?: string;
      /**
       * Format: int64
       * @description Time at which the block was produced.
       * Will be used to inform the core at what time
       * the stake started to be available.
       */
      readonly blockTime?: string;
      /** Ethereum Address of the user depositing stake (hex encode with 0x prefix) */
      readonly ethereumAddress?: string;
      /** @description Hex encoded public key of the party receiving the stake deposit. */
      readonly vegaPublicKey?: string;
    };
    readonly vegaStakeRemoved: {
      /** @description Amount removed as a base 10 unsigned integer scaled to the asset's decimal places. */
      readonly amount?: string;
      /**
       * Format: int64
       * @description The time at which the block was produced
       * will be used to inform the core at what time
       * the stake was made unavailable.
       */
      readonly blockTime?: string;
      /** @description Ethereum address of the user removing stake. This should be hex encoded with 0x prefix. */
      readonly ethereumAddress?: string;
      /** @description Hex encoded public key of the party from which to remove stake. */
      readonly vegaPublicKey?: string;
    };
    readonly vegaStakeTotalSupply: {
      /** Address of the staking asset */
      readonly tokenAddress?: string;
      /** @description Total supply observed for the token as an unsigned based 10 integer scaled to the asset's decimal places. */
      readonly totalSupply?: string;
    };
    /** @description Event related to staking on the Vega network. */
    readonly vegaStakingEvent: {
      /**
       * Format: uint64
       * @description Block in which the transaction was added.
       */
      readonly block?: string;
      /**
       * Format: uint64
       * @description Index of the log in the transaction.
       */
      readonly index?: string;
      readonly stakeDeposited?: components['schemas']['vegaStakeDeposited'];
      readonly stakeRemoved?: components['schemas']['vegaStakeRemoved'];
      readonly totalSupply?: components['schemas']['vegaStakeTotalSupply'];
    };
    readonly vegaStateValueProposal: {
      /** @description Event ID. */
      readonly eventId?: string;
      /** @description Key value tolerance triplets. */
      readonly kvb?: readonly components['schemas']['vegaKeyValueBundle'][];
      /** @description State variable ID. */
      readonly stateVarId?: string;
    };
    readonly vegaStateVarValue: {
      readonly matrixVal?: components['schemas']['vegaMatrixValue'];
      readonly scalarVal?: components['schemas']['vegaScalarValue'];
      readonly vectorVal?: components['schemas']['vegaVectorValue'];
    };
    /** @description Configuration required to turn a new market proposal in to a successor market proposal. */
    readonly vegaSuccessorConfiguration: {
      /** @description A decimal value between or equal to 0 and 1, specifying the fraction of the insurance pool balance that is carried over from the parent market to the successor. */
      readonly insurancePoolFraction?: string;
      /** @description ID of the market that the successor should take over from. */
      readonly parentMarketId?: string;
    };
    /** TargetStakeParameters contains parameters used in target stake calculation */
    readonly vegaTargetStakeParameters: {
      /**
       * Format: double
       * @description Specifies scaling factors used in target stake calculation.
       */
      readonly scalingFactor?: number;
      /**
       * Format: int64
       * @description Specifies length of time window expressed in seconds for target stake calculation.
       */
      readonly timeWindow?: string;
    };
    /** Update an existing asset on Vega */
    readonly vegaUpdateAsset: {
      /** @description Asset ID the update is for. */
      readonly assetId?: string;
      /** @description Changes to apply on an existing asset. */
      readonly changes?: components['schemas']['vegaAssetDetailsUpdate'];
    };
    /** Future product configuration */
    readonly vegaUpdateFutureProduct: {
      /** @description The binding between the data source spec and the settlement data. */
      readonly dataSourceSpecBinding?: components['schemas']['vegaDataSourceSpecToFutureBinding'];
      /** @description The data source spec describing the data of settlement data. */
      readonly dataSourceSpecForSettlementData?: components['schemas']['vegaDataSourceDefinition'];
      /** @description The data source spec describing the data source for trading termination. */
      readonly dataSourceSpecForTradingTermination?: components['schemas']['vegaDataSourceDefinition'];
      /** @description Human-readable name/abbreviation of the quote name. */
      readonly quoteName?: string;
    };
    /** Instrument configuration */
    readonly vegaUpdateInstrumentConfiguration: {
      /** @description Instrument code, human-readable shortcode used to describe the instrument. */
      readonly code?: string;
      /** @description Future. */
      readonly future?: components['schemas']['vegaUpdateFutureProduct'];
    };
    /** Update an existing market on Vega */
    readonly vegaUpdateMarket: {
      /** @description Updated configuration of the futures market. */
      readonly changes?: components['schemas']['vegaUpdateMarketConfiguration'];
      /** @description Market ID the update is for. */
      readonly marketId?: string;
    };
    /** Configuration to update a futures market on Vega */
    readonly vegaUpdateMarketConfiguration: {
      /** @description Updated futures market instrument configuration. */
      readonly instrument?: components['schemas']['vegaUpdateInstrumentConfiguration'];
      /** @description Linear slippage factor is used to cap the slippage component of maintenance margin - it is applied to the slippage volume. */
      readonly linearSlippageFactor?: string;
      /** @description Liquidity monitoring parameters. */
      readonly liquidityMonitoringParameters?: components['schemas']['vegaLiquidityMonitoringParameters'];
      /** @description Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected. */
      readonly logNormal?: components['schemas']['vegaLogNormalRiskModel'];
      /**
       * @description Percentage move up and down from the mid price which specifies the range of
       * price levels over which automated liquidity provision orders will be deployed.
       */
      readonly lpPriceRange?: string;
      /** @description Optional futures market metadata, tags. */
      readonly metadata?: readonly string[];
      /** @description Price monitoring parameters. */
      readonly priceMonitoringParameters?: components['schemas']['vegaPriceMonitoringParameters'];
      /** @description Quadratic slippage factor is used to cap the slippage component of maintenance margin - it is applied to the square of the slippage volume. */
      readonly quadraticSlippageFactor?: string;
      /** @description Simple risk model parameters, valid only if MODEL_SIMPLE is selected. */
      readonly simple?: components['schemas']['vegaSimpleModelParams'];
    };
    /** Update network configuration on Vega */
    readonly vegaUpdateNetworkParameter: {
      /** @description The network parameter to update. */
      readonly changes?: components['schemas']['vegaNetworkParameter'];
    };
    /** Update an existing spot market on Vega */
    readonly vegaUpdateSpotMarket: {
      /** @description Updated configuration of the spot market. */
      readonly changes?: components['schemas']['vegaUpdateSpotMarketConfiguration'];
      /** @description Market ID the update is for. */
      readonly marketId?: string;
    };
    /** Configuration to update a spot market on Vega */
    readonly vegaUpdateSpotMarketConfiguration: {
      /** @description Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected. */
      readonly logNormal?: components['schemas']['vegaLogNormalRiskModel'];
      /** @description Optional spot market metadata, tags. */
      readonly metadata?: readonly string[];
      /** @description Price monitoring parameters. */
      readonly priceMonitoringParameters?: components['schemas']['vegaPriceMonitoringParameters'];
      /** @description Simple risk model parameters, valid only if MODEL_SIMPLE is selected. */
      readonly simple?: components['schemas']['vegaSimpleModelParams'];
      /** @description Specifies parameters related to target stake calculation. */
      readonly targetStakeParameters?: components['schemas']['vegaTargetStakeParameters'];
    };
    readonly vegaVectorValue: {
      readonly value?: readonly string[];
    };
    /**
     * Vote value
     * @description - VALUE_UNSPECIFIED: Default value, always invalid
     *  - VALUE_NO: Vote against the proposal
     *  - VALUE_YES: Vote in favour of the proposal
     * @default VALUE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaVoteValue: 'VALUE_UNSPECIFIED' | 'VALUE_NO' | 'VALUE_YES';
    /** Withdrawal external details */
    readonly vegaWithdrawExt: {
      /** @description ERC20 withdrawal details. */
      readonly erc20?: components['schemas']['vegaErc20WithdrawExt'];
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {
  /**
   * Info
   * @description Get information about the block explorer.
   * Response contains a semver formatted version of the data node and the commit hash, from which the block explorer was built
   */
  BlockExplorer_Info: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          readonly 'application/json': components['schemas']['v1InfoResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          readonly 'application/json': components['schemas']['googlerpcStatus'];
        };
      };
    };
  };
  /**
   * List transactions
   * @description List transactions from the Vega blockchain
   */
  BlockExplorer_ListTransactions: {
    parameters: {
      query?: {
        /**
         * @description Number of transactions to be returned from the blockchain.
         * This is deprecated, use first and last instead.
         */
        limit?: number;
        /** @description Optional cursor to paginate the request. */
        before?: string;
        /** @description Optional cursor to paginate the request. */
        after?: string;
        /** @description Transaction command types filter, for listing transactions with specified command types. */
        cmdTypes?: readonly string[];
        /** @description Transaction command types exclusion filter, for listing all the transactions except the ones with specified command types. */
        excludeCmdTypes?: readonly string[];
        /** @description Party IDs filter, can be sender or receiver. */
        parties?: readonly string[];
        /**
         * @description Number of transactions to be returned from the blockchain. Use in conjunction with the `after` cursor to paginate forwards.
         * On its own, this will return the first `first` transactions.
         */
        first?: number;
        /**
         * @description Number of transactions to be returned from the blockchain. Use in conjunction with the `before` cursor to paginate backwards.
         * On its own, this will return the last `last` transactions.
         */
        last?: number;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          readonly 'application/json': components['schemas']['v1ListTransactionsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          readonly 'application/json': components['schemas']['googlerpcStatus'];
        };
      };
    };
  };
  /**
   * Get transaction
   * @description Get a transaction from the Vega blockchain
   */
  BlockExplorer_GetTransaction: {
    parameters: {
      path: {
        /** @description Hash of the transaction */
        hash: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          readonly 'application/json': components['schemas']['v1GetTransactionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          readonly 'application/json': components['schemas']['googlerpcStatus'];
        };
      };
    };
  };
}
