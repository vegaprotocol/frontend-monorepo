/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = T | U extends object
  ? (Without<T, U> & U) | (Without<U, T> & T)
  : T | U;
/* eslint-disable @typescript-eslint/no-explicit-any */
type OneOf<T extends any[]> = T extends [infer Only]
  ? Only
  : T extends [infer A, infer B, ...infer Rest]
  ? OneOf<[XOR<A, B>, ...Rest]>
  : never;
/* eslint-enable @typescript-eslint/no-explicit-any */

export interface paths {
  '/info': {
    /**
     * Info
     * @description Get information about the block explorer.
     * Response contains a semver formatted version of the data node and the commit hash, from which the block explorer was built
     */
    get: operations['BlockExplorer_Info'];
  };
  '/transactions': {
    /**
     * List transactions
     * @description List transactions from the Vega blockchain
     */
    get: operations['BlockExplorer_ListTransactions'];
  };
  '/transactions/{hash}': {
    /**
     * Get transaction
     * @description Get a transaction from the Vega blockchain
     */
    get: operations['BlockExplorer_GetTransaction'];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /**
     * @description Operator describes the type of comparison.
     *
     *  - OPERATOR_UNSPECIFIED: The default value
     *  - OPERATOR_EQUALS: Verify if the property values are strictly equal or not.
     *  - OPERATOR_GREATER_THAN: Verify if the data source data value is greater than the Condition value.
     *  - OPERATOR_GREATER_THAN_OR_EQUAL: Verify if the data source data value is greater than or equal to the Condition
     * value.
     *  - OPERATOR_LESS_THAN: Verify if the data source data value is less than the Condition value.
     *  - OPERATOR_LESS_THAN_OR_EQUAL: Verify if the data source data value is less or equal to than the Condition
     * value.
     * @default OPERATOR_UNSPECIFIED
     * @enum {string}
     */
    readonly ConditionOperator:
      | 'OPERATOR_UNSPECIFIED'
      | 'OPERATOR_EQUALS'
      | 'OPERATOR_GREATER_THAN'
      | 'OPERATOR_GREATER_THAN_OR_EQUAL'
      | 'OPERATOR_LESS_THAN'
      | 'OPERATOR_LESS_THAN_OR_EQUAL';
    /**
     * Supported oracle sources
     * @description - ORACLE_SOURCE_UNSPECIFIED: Default value
     *  - ORACLE_SOURCE_OPEN_ORACLE: Specifies that the payload will be base64 encoded JSON conforming to the Open Oracle standard.
     *  - ORACLE_SOURCE_JSON: Specifies that the payload will be base64 encoded JSON, but does not specify the shape of the data.
     *  - ORACLE_SOURCE_ETHEREUM: Specifies that the payload will be base64 encoded JSON conforming to the ETH standard.
     * @default ORACLE_SOURCE_UNSPECIFIED
     * @enum {string}
     */
    readonly OracleDataSubmissionOracleSource:
      | 'ORACLE_SOURCE_UNSPECIFIED'
      | 'ORACLE_SOURCE_OPEN_ORACLE'
      | 'ORACLE_SOURCE_JSON'
      | 'ORACLE_SOURCE_ETHEREUM';
    /**
     * Time In Force for an order
     * @description - TIME_IN_FORCE_UNSPECIFIED: Default value for TimeInForce, can be valid for an amend
     *  - TIME_IN_FORCE_GTC: Good until cancelled, the order trades any amount and as much as possible
     * and remains on the book until it either trades completely or is cancelled
     *  - TIME_IN_FORCE_GTT: Good until specified time, this order type trades any amount and as much as possible
     * and remains on the book until it either trades completely, is cancelled, or expires at a set time
     * NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
     *  - TIME_IN_FORCE_IOC: Immediate or cancel, the order trades any amount and as much as possible
     * but does not remain on the book (whether it trades or not)
     *  - TIME_IN_FORCE_FOK: Fill or kill, the order either trades completely i.e. remainingSize == 0 after adding,
     * or not at all, and does not remain on the book if it doesn't trade
     *  - TIME_IN_FORCE_GFA: Good for auction, this order is only accepted during an auction period
     *  - TIME_IN_FORCE_GFN: Good for normal, this order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)
     * @default TIME_IN_FORCE_UNSPECIFIED
     * @enum {string}
     */
    readonly OrderTimeInForce:
      | 'TIME_IN_FORCE_UNSPECIFIED'
      | 'TIME_IN_FORCE_GTC'
      | 'TIME_IN_FORCE_GTT'
      | 'TIME_IN_FORCE_IOC'
      | 'TIME_IN_FORCE_FOK'
      | 'TIME_IN_FORCE_GFA'
      | 'TIME_IN_FORCE_GFN';
    /**
     * @description  - EXPIRY_STRATEGY_UNSPECIFIED: Never valid
     *  - EXPIRY_STRATEGY_CANCELS: Stop order should be cancelled if the expiry time is reached.
     *  - EXPIRY_STRATEGY_SUBMIT: Order should be submitted if the expiry time is reached.
     * @default EXPIRY_STRATEGY_UNSPECIFIED
     * @enum {string}
     */
    readonly StopOrderExpiryStrategy:
      | 'EXPIRY_STRATEGY_UNSPECIFIED'
      | 'EXPIRY_STRATEGY_CANCELS'
      | 'EXPIRY_STRATEGY_SUBMIT';
    /**
     * @description  - METHOD_NOW: Undelegate straight away, losing all rewards for the current epoch.
     *  - METHOD_AT_END_OF_EPOCH: Undelegate at the end of an epoch, retaining all rewards for the current epoch.
     * @default METHOD_UNSPECIFIED
     * @enum {string}
     */
    readonly UndelegateSubmissionMethod:
      | 'METHOD_UNSPECIFIED'
      | 'METHOD_NOW'
      | 'METHOD_AT_END_OF_EPOCH';
    readonly blockexplorerapiv1Transaction: {
      /**
       * Height of the block the transaction was found in
       * Format: uint64
       */
      readonly block?: string;
      /**
       * Results code of the transaction. 0 indicates the transaction was successful
       * Format: int64
       */
      readonly code?: number;
      /** Actual command of the transaction */
      readonly command?: components['schemas']['v1InputData'];
      /** @description Timestamp when the transaction happened, using RFC3399 format. */
      readonly createdAt?: string;
      /** Cursor for this transaction. This is used for paginating results */
      readonly cursor?: string;
      /**
       * Optional error happening when processing / checking the transaction
       * This should be set if error code is not 0
       */
      readonly error?: string;
      /** Hash of the transaction */
      readonly hash?: string;
      /**
       * Index of the transaction in the block
       * Format: int64
       */
      readonly index?: number;
      /** Proof of Work parameters of the transaction */
      readonly pow?: components['schemas']['v1ProofOfWork'];
      /** Signature generated by the submitter for the transaction */
      readonly signature?: components['schemas']['v1Signature'];
      /** Vega public key of the transaction's submitter */
      readonly submitter?: string;
      /** Type of transaction */
      readonly type?: string;
      /** Version format of the transaction */
      readonly version?: components['schemas']['v1TxVersion'];
    };
    /** @description Command that can be used by the party that initiated a transfer to instruct the network to stop an active recurring transaction. */
    readonly commandsv1CancelTransfer: {
      /** @description Transfer ID of the transfer to cancel. */
      readonly transferId?: string;
    };
    /** @description Details for a one-off transfer. */
    readonly commandsv1OneOffTransfer: {
      /**
       * Format: int64
       * @description Timestamp, in Unix nanoseconds, for when the transfer should be executed, i.e., assets transferred into the receiver's account.
       */
      readonly deliverOn?: string;
    };
    /** Details for a recurring transfer */
    readonly commandsv1RecurringTransfer: {
      /** @description Optional parameter defining how a transfer is dispatched. */
      readonly dispatchStrategy?: components['schemas']['vegaDispatchStrategy'];
      /**
       * Format: uint64
       * @description Last epoch at which this transfer shall be executed.
       */
      readonly endEpoch?: string;
      /**
       * @description Factor that the initial transfer amount is multiplied by for each epoch that it is executed.
       * For example if the initial transfer amount is 1000 and the factor is 0.5, then the amounts transferred per epoch will be 1000, 500, 250, 125, etc.
       */
      readonly factor?: string;
      /**
       * Format: uint64
       * @description First epoch from which this transfer shall be executed.
       */
      readonly startEpoch?: string;
    };
    /**
     * Command that allows a party to move assets from one account to another.
     * A transfer can be set up as a single one-off transfer, or a recurring transfer that occurs once at the start of each epoch.
     * Each transfer incurs a fee as specified by the network parameter `transfer.fee.factor`
     */
    readonly commandsv1Transfer: {
      /** @description Amount to be taken from the source account, as an unsigned integer scaled to the asset's decimal places. */
      readonly amount?: string;
      /** @description Asset ID of the asset to be transferred. */
      readonly asset?: string;
      /** @description Account type from which the funds of the party should be taken. */
      readonly fromAccountType?: components['schemas']['vegaAccountType'];
      /** @description Details of a one-off transfer that is executed once at a specified time. */
      readonly oneOff?: components['schemas']['commandsv1OneOffTransfer'];
      /** @description Details of a transfer that is executed once every epoch until stopped. */
      readonly recurring?: components['schemas']['commandsv1RecurringTransfer'];
      /** @description Reference to be attached to the transfer. */
      readonly reference?: string;
      /** @description Public key of the destination account. */
      readonly to?: string;
      /** @description Type of the destination account. */
      readonly toAccountType?: components['schemas']['vegaAccountType'];
    };
    readonly googlerpcStatus: {
      /** Format: int32 */
      readonly code?: number;
      readonly details?: readonly components['schemas']['protobufAny'][];
      readonly message?: string;
    };
    readonly protobufAny: {
      readonly '@type'?: string;
      [key: string]: unknown;
    };
    /**
     * @description `NullValue` is a singleton enumeration to represent the null value for the
     * `Value` type union.
     *
     *  The JSON representation for `NullValue` is JSON `null`.
     *
     *  - NULL_VALUE: Null value.
     * @default NULL_VALUE
     * @enum {string}
     */
    readonly protobufNullValue: 'NULL_VALUE';
    /** @description A command that allows a new node operator to announce themselves to the network as a new validator. */
    readonly v1AnnounceNode: {
      /** @description URL to the node operator's avatar. */
      readonly avatarUrl?: string;
      /** @description Public key for the blockchain, currently the node's CometBFT key. */
      readonly chainPubKey?: string;
      /** @description Country code (ISO 3166-1 alpha-2) for the location of the node. */
      readonly country?: string;
      /** @description Ethereum public key of the node being announced. */
      readonly ethereumAddress?: string;
      /** @description Signature from the node made using the ethereum wallet. */
      readonly ethereumSignature?: components['schemas']['v1Signature'];
      /**
       * Format: uint64
       * @description Epoch from which the node is expected to be ready to validate blocks.
       */
      readonly fromEpoch?: string;
      /** @description Node ID of the validator, which is the node's public master key. */
      readonly id?: string;
      /** @description URL to the node operators homepage allowing stake holders to make an informed decision when delegating. */
      readonly infoUrl?: string;
      /** @description Human-readable name of the node. */
      readonly name?: string;
      /** @description Ethereum public key to use as a submitter to allow automatic signature generation. */
      readonly submitterAddress?: string;
      /** @description Vega public key of the node being announced. */
      readonly vegaPubKey?: string;
      /**
       * Format: int64
       * @description Vega public key derivation index.
       */
      readonly vegaPubKeyIndex?: number;
      /** @description Signature from the node made using the Vega wallet. */
      readonly vegaSignature?: components['schemas']['v1Signature'];
    };
    /**
     * @description Command that allows the submitter to join a referral set and earn a collective reduction in fees based on the activity of all members of that set.
     * A party that joins a referral set is called a referee. A referee can only be a member of one referral set and cannot themselves be or become a referrer.
     * To switch to another referral set, a subsequent command can be sent and the switch will take effect at the end of the epoch.
     */
    readonly v1ApplyReferralCode: {
      /** @description Referral code, normally the referral set ID, for the party to join. */
      readonly id?: string;
    };
    /**
     * @description A command that allows the submission of a batch market instruction which wraps up multiple market instructions into a single transaction.
     * These instructions are then processed sequentially in the following order:
     * - OrderCancellation
     * - OrderAmendment
     * - OrderSubmission
     * - StopOrderSubmission
     * where the maximum allow of instructions in a batch is controlled by the network parameter "spam.protection.max.batchSize".
     */
    readonly v1BatchMarketInstructions: {
      /** @description List of order amendments to be processed sequentially. */
      readonly amendments?: readonly components['schemas']['v1OrderAmendment'][];
      /** @description List of order cancellations to be processed sequentially. */
      readonly cancellations?: readonly components['schemas']['v1OrderCancellation'][];
      /** @description List of stop order cancellations to be processed sequentially. */
      readonly stopOrdersCancellation?: readonly components['schemas']['v1StopOrdersCancellation'][];
      /** @description List of stop order submissions to be processed sequentially. */
      readonly stopOrdersSubmission?: readonly components['schemas']['v1StopOrdersSubmission'][];
      /** @description List of order submissions to be processed sequentially. */
      readonly submissions?: readonly components['schemas']['v1OrderSubmission'][];
    };
    /** @description A validator command sent automatically that provides information of events that have happened on foreign chains. */
    readonly v1ChainEvent: {
      /** @description Built-in asset event. */
      readonly builtin?: components['schemas']['vegaBuiltinAssetEvent'];
      /** @description Ethereum contract call event. */
      readonly contractCall?: components['schemas']['vegaEthContractCallEvent'];
      /** @description Ethereum ERC20 event. */
      readonly erc20?: components['schemas']['vegaERC20Event'];
      /** @description Ethereum ERC20 multisig event. */
      readonly erc20Multisig?: components['schemas']['vegaERC20MultiSigEvent'];
      /**
       * Format: uint64
       * @description Arbitrary one-time integer used to prevent replay attacks.
       */
      readonly nonce?: string;
      /** @description Ethereum Staking event. */
      readonly stakingEvent?: components['schemas']['vegaStakingEvent'];
      /** @description ID of the transaction on the foreign chain that caused the event. */
      readonly txId?: string;
    };
    /** Condition describes the condition that must be validated by the network */
    readonly v1Condition: {
      /** @description Type of comparison to make on the value. */
      readonly operator?: components['schemas']['ConditionOperator'];
      /** @description Value to be compared with by the operator. */
      readonly value?: string;
    };
    /**
     * @description Command that a party can use to instruct the network to create a new referral set on the network.
     * The submitter of this command will become the referrer of the new set and cannot be the referrer or a referee of another set.
     * A referrer can use the referral set ID as a referral code to attract others to the Vega network and have fees reduced for the referral set.
     */
    readonly v1CreateReferralSet: {
      /** @description Whether or not the referral set should be considered a team that can participate in team games on the network. */
      readonly isTeam?: boolean;
      /** @description Team details, if the referral set is to be considered a team. */
      readonly team?: components['schemas']['v1CreateReferralSetTeam'];
    };
    readonly v1CreateReferralSetTeam: {
      /** @description External link to an avatar for the team. */
      readonly avatarUrl?: string;
      /** @description Whether or not the team is closed to new party members. */
      readonly closed?: boolean;
      /** @description Name of the team. */
      readonly name?: string;
      /** @description External link to the team's homepage. */
      readonly teamUrl?: string;
    };
    /**
     * @description Command to allow a token holder to delegate their tokens to a validator to help secure the network.
     * A token holder delegating to a validator will earn rewards based on the amount they have delegated, and the performance of the chosen validator.
     */
    readonly v1DelegateSubmission: {
      /** @description Amount of stake to delegate, as an unsigned integer scaled to the governance asset's decimal places. */
      readonly amount?: string;
      /** @description Node ID to delegate stake to. */
      readonly nodeId?: string;
    };
    readonly v1ETHAddress: {
      readonly address?: string;
    };
    /** @description A validator command sent manually that allows a node operator to indicate to the network that their node's Ethereum key will be rotated. */
    readonly v1EthereumKeyRotateSubmission: {
      /** @description Ethereum address of the node's current Ethereum keys. */
      readonly currentAddress?: string;
      /** @description Signature signed by the new Ethereum key that can be verified to prove ownership. */
      readonly ethereumSignature?: components['schemas']['v1Signature'];
      /** @description Ethereum address that is being rotated to. */
      readonly newAddress?: string;
      /** @description Ethereum public key to use as a submitter to allow automatic signature generation. */
      readonly submitterAddress?: string;
      /**
       * Format: uint64
       * @description Block height at which the key rotation will take effect.
       */
      readonly targetBlock?: string;
    };
    /**
     * @description Filter describes the conditions under which a data source data is considered of
     * interest or not.
     */
    readonly v1Filter: {
      /**
       * @description Conditions that should be matched by the data to be
       * considered of interest.
       */
      readonly conditions?: readonly components['schemas']['v1Condition'][];
      /** @description Data source's data property key targeted by the filter. */
      readonly key?: components['schemas']['v1PropertyKey'];
    };
    readonly v1GetTransactionResponse: {
      /** Transaction corresponding to the hash */
      readonly transaction?: components['schemas']['blockexplorerapiv1Transaction'];
    };
    /** Iceberg order options */
    readonly v1IcebergOpts: {
      /**
       * Format: uint64
       * @description Minimum allowed remaining size of the order before it is replenished back to its peak size.
       */
      readonly minimumVisibleSize?: string;
      /**
       * Format: uint64
       * @description Size of the order that is made visible and can be traded with during the execution of a single order.
       */
      readonly peakSize?: string;
    };
    readonly v1InfoResponse: {
      /** Commit hash from which the data node was built */
      readonly commitHash?: string;
      /** Semver formatted version of the data node */
      readonly version?: string;
    };
    /**
     * @description Input data for a transaction containing a network command for the Vega network to execute.
     * Once populated the protobuf message should be marshalled into a byte array and included in a transaction message.
     */
    readonly v1InputData: {
      /** @description Command used by a node operator to announce its node as a pending validator. */
      readonly announceNode?: components['schemas']['v1AnnounceNode'];
      /** @description Command to apply a referral code. */
      readonly applyReferralCode?: components['schemas']['v1ApplyReferralCode'];
      /** @description Command to submit a batch of order instructions. */
      readonly batchMarketInstructions?: components['schemas']['v1BatchMarketInstructions'];
      /**
       * Format: uint64
       * @description Block height which has been used to calculate the transaction proof-of-work.
       */
      readonly blockHeight?: string;
      /** @description Command to cancel a recurring transfer. */
      readonly cancelTransfer?: components['schemas']['commandsv1CancelTransfer'];
      /** @description Validator command sent automatically to notify the Vega chain of an off-chain event. */
      readonly chainEvent?: components['schemas']['v1ChainEvent'];
      /** @description Command to create a referral set. */
      readonly createReferralSet?: components['schemas']['v1CreateReferralSet'];
      /** @description Command to delegate tokens to a validator. */
      readonly delegateSubmission?: components['schemas']['v1DelegateSubmission'];
      /** @description Validator command sent manually by a node operator to rotate their node's Ethereum keys. */
      readonly ethereumKeyRotateSubmission?: components['schemas']['v1EthereumKeyRotateSubmission'];
      /** @description Command to request signatures to amend the multisig-control contract. */
      readonly issueSignatures?: components['schemas']['v1IssueSignatures'];
      /** @description Validator command sent manually by a node operator to rotate their node's Vega keys. */
      readonly keyRotateSubmission?: components['schemas']['v1KeyRotateSubmission'];
      /** @description Command to amend a liquidity commitment. */
      readonly liquidityProvisionAmendment?: components['schemas']['v1LiquidityProvisionAmendment'];
      /** @description Command to cancel a liquidity commitment. */
      readonly liquidityProvisionCancellation?: components['schemas']['v1LiquidityProvisionCancellation'];
      /** @description Command to submit a liquidity commitment. */
      readonly liquidityProvisionSubmission?: components['schemas']['v1LiquidityProvisionSubmission'];
      /** @description Validator command sent automatically to provide signatures for the Ethereum bridge. */
      readonly nodeSignature?: components['schemas']['v1NodeSignature'];
      /** @description Validator command sent automatically to vote on that validity of an external resource. */
      readonly nodeVote?: components['schemas']['v1NodeVote'];
      /**
       * Format: uint64
       * @description Arbitrary number used to provide uniqueness to the signature of two otherwise identical input data, preventing replay attacks.
       * Must be set to a different value for all new transactions sent by a party. It is advised to generate this number randomly.
       */
      readonly nonce?: string;
      /** @description Command to submit external oracle data. */
      readonly oracleDataSubmission?: components['schemas']['v1OracleDataSubmission'];
      /** @description Command to amend an order. */
      readonly orderAmendment?: components['schemas']['v1OrderAmendment'];
      /** @description Command to cancel an order. */
      readonly orderCancellation?: components['schemas']['v1OrderCancellation'];
      /** @description Command to submit an order. */
      readonly orderSubmission?: components['schemas']['v1OrderSubmission'];
      /** @description Command to submit a governance proposal. */
      readonly proposalSubmission?: components['schemas']['v1ProposalSubmission'];
      /** @description Validator command sent manually to propose a protocol upgrade. */
      readonly protocolUpgradeProposal?: components['schemas']['v1ProtocolUpgradeProposal'];
      /** @description Validator command sent automatically to reach consensus on floating point values. */
      readonly stateVariableProposal?: components['schemas']['v1StateVariableProposal'];
      /** @description Command to cancel stop orders. */
      readonly stopOrdersCancellation?: components['schemas']['v1StopOrdersCancellation'];
      /** @description Command to submit a pair of stop orders. */
      readonly stopOrdersSubmission?: components['schemas']['v1StopOrdersSubmission'];
      /** @description Command to submit a transfer. */
      readonly transfer?: components['schemas']['commandsv1Transfer'];
      /** @description Command to remove tokens delegated to a validator. */
      readonly undelegateSubmission?: components['schemas']['v1UndelegateSubmission'];
      /** @description Command to update a referral set. */
      readonly updateReferralSet?: components['schemas']['v1UpdateReferralSet'];
      /** @description Validator command sent automatically to signal regular participation in the network. */
      readonly validatorHeartbeat?: components['schemas']['v1ValidatorHeartbeat'];
      /** @description Command to submit a vote on a governance proposal. */
      readonly voteSubmission?: components['schemas']['v1VoteSubmission'];
      /** @description Command to submit a withdrawal. */
      readonly withdrawSubmission?: components['schemas']['v1WithdrawSubmission'];
    };
    /** @description Trigger for an internal time data source. */
    readonly v1InternalTimeTrigger: {
      /**
       * Format: int64
       * @description Repeat the trigger every n seconds after the initial. If no time for
       * initial was specified, begin repeating immediately.
       */
      readonly every?: string;
      /**
       * Format: int64
       * @description Trigger when the vega time is greater or equal to this time, in Unix seconds.
       */
      readonly initial?: string;
    };
    /**
     * @description Command that can be used by a validator to instruct the network to generate signatures to add or remove validators from the multisig-control contract.
     * Signatures can only be generated for validator nodes that have been promoted or demoted from the consensus validator set, and any attempt to generate signatures for another node will be rejected.
     * The generated signatures can only be submitted to the contract by the Ethereum addresses included in the command.
     */
    readonly v1IssueSignatures: {
      /** @description What kind of signatures to generate, namely for whether a signer is being added or removed. */
      readonly kind?: components['schemas']['v1NodeSignatureKind'];
      /** @description Ethereum address which will submit the signatures to the smart contract. */
      readonly submitter?: string;
      /** @description Node ID of the validator node that will be signed in or out of the smart contract. */
      readonly validatorNodeId?: string;
    };
    /** @description A validator command sent manually that allows a node operator to indicate to the network that their node's Vega key will be rotated. */
    readonly v1KeyRotateSubmission: {
      /** @description Hash of the node's current Vega public key. */
      readonly currentPubKeyHash?: string;
      /** @description Vega public key that would be rotated to. */
      readonly newPubKey?: string;
      /**
       * Format: int64
       * @description New Vega public key derivation index.
       */
      readonly newPubKeyIndex?: number;
      /**
       * Format: uint64
       * @description Block height at which the key rotation will take effect.
       */
      readonly targetBlock?: string;
    };
    /**
     * @description Command that allows a liquidity provider to update the details of their existing liquidity commitment.
     * Any field that is left unset or as a default value indicates that this field on the original submission will be left unchanged.
     */
    readonly v1LiquidityProvisionAmendment: {
      /** @description New commitment amount. */
      readonly commitmentAmount?: string;
      /** @description New nominated liquidity fee factor. */
      readonly fee?: string;
      /** @description Market that the submitter wants to amend the liquidity commitment for. */
      readonly marketId?: string;
      /** @description New arbitrary reference to be added to every order created out of this liquidity provision submission. */
      readonly reference?: string;
    };
    /** @description Command that allows a liquidity provider to inform the network that they will stop providing liquidity for a market. */
    readonly v1LiquidityProvisionCancellation: {
      /** @description Market that the submitter will stop providing liquidity for. */
      readonly marketId?: string;
    };
    /**
     * @description A command that indicates to the network the party's intention to supply liquidity to the given market and become a liquidity provider.
     * An active liquidity provider for a market will earn fees based on the trades that occur in the market.
     */
    readonly v1LiquidityProvisionSubmission: {
      /**
       * @description Amount that the submitter will commit as liquidity to the market, specified as a unitless number in the settlement asset of the market.
       * This field is an unsigned integer scaled using the asset's decimal places.
       */
      readonly commitmentAmount?: string;
      /** @description Nominated liquidity fee factor, which is an input to the calculation of taker fees on the market, as per setting fees and rewarding liquidity providers. */
      readonly fee?: string;
      /** @description Market that the submitter wishes to provide liquidity for. */
      readonly marketId?: string;
      /** @description Arbitrary reference to be added to every order created out of this liquidity provision submission. */
      readonly reference?: string;
    };
    readonly v1ListTransactionsResponse: {
      /** Transaction corresponding to the specific request and filters */
      readonly transactions?: readonly components['schemas']['blockexplorerapiv1Transaction'][];
    };
    /** @description A validator command sent automatically containing a signature that can be used on a foreign chain to process an action. */
    readonly v1NodeSignature: {
      /** @description ID of the resource that the signature relates to. */
      readonly id?: string;
      /** @description Kind of resource being signed. */
      readonly kind?: components['schemas']['v1NodeSignatureKind'];
      /**
       * Format: byte
       * @description Signature generated by the node.
       */
      readonly sig?: string;
    };
    /**
     * Kind of signature created by a node, for example, allow-listing a new asset, withdrawal etc
     * @description - NODE_SIGNATURE_KIND_UNSPECIFIED: Represents an unspecified or missing value from the input.
     *  - NODE_SIGNATURE_KIND_ASSET_NEW: Represents a signature for a new asset allow-listing.
     *  - NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL: Represents a signature for an asset withdrawal.
     *  - NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED: Represents a signature for a new signer added to the erc20 multisig contract.
     *  - NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED: Represents a signature for a signer removed from the erc20 multisig contract.
     *  - NODE_SIGNATURE_KIND_ASSET_UPDATE: Represents a signature for an asset update allow-listing.
     * @default NODE_SIGNATURE_KIND_UNSPECIFIED
     * @enum {string}
     */
    readonly v1NodeSignatureKind:
      | 'NODE_SIGNATURE_KIND_UNSPECIFIED'
      | 'NODE_SIGNATURE_KIND_ASSET_NEW'
      | 'NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL'
      | 'NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED'
      | 'NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED'
      | 'NODE_SIGNATURE_KIND_ASSET_UPDATE';
    /** @description A validator command which is sent automatically by a node when it has verified a resource external to the network. */
    readonly v1NodeVote: {
      /** @description Reference identifying the resource that has been verified. */
      readonly reference?: string;
      /** @description Type of external event that has been verified. */
      readonly type?: components['schemas']['v1NodeVoteType'];
    };
    /**
     * - TYPE_UNSPECIFIED: Represents an unspecified or missing value from the input
     *  - TYPE_STAKE_DEPOSITED: Node vote for a new stake deposit
     *  - TYPE_STAKE_REMOVED: Node vote for a new stake removed event
     *  - TYPE_FUNDS_DEPOSITED: Node vote for a new collateral deposit
     *  - TYPE_SIGNER_ADDED: Node vote for a new signer added to the erc20 bridge
     *  - TYPE_SIGNER_REMOVED: Node vote for a signer removed from the erc20 bridge
     *  - TYPE_BRIDGE_STOPPED: Node vote for a bridge stopped event
     *  - TYPE_BRIDGE_RESUMED: Node vote for a bridge resumed event
     *  - TYPE_ASSET_LISTED: Node vote for a newly listed asset
     *  - TYPE_LIMITS_UPDATED: Node vote for an asset limits update
     *  - TYPE_STAKE_TOTAL_SUPPLY: Node vote to share the total supply of the staking token
     *  - TYPE_SIGNER_THRESHOLD_SET: Node vote to update the threshold of the signer set for the multisig contract
     *  - TYPE_GOVERNANCE_VALIDATE_ASSET: Node vote to validate a new assert governance proposal
     *  - TYPE_ETHEREUM_CONTRACT_CALL_RESULT: Node vote for an Ethereum contract call result
     * @default TYPE_UNSPECIFIED
     * @enum {string}
     */
    readonly v1NodeVoteType:
      | 'TYPE_UNSPECIFIED'
      | 'TYPE_STAKE_DEPOSITED'
      | 'TYPE_STAKE_REMOVED'
      | 'TYPE_FUNDS_DEPOSITED'
      | 'TYPE_SIGNER_ADDED'
      | 'TYPE_SIGNER_REMOVED'
      | 'TYPE_BRIDGE_STOPPED'
      | 'TYPE_BRIDGE_RESUMED'
      | 'TYPE_ASSET_LISTED'
      | 'TYPE_LIMITS_UPDATED'
      | 'TYPE_STAKE_TOTAL_SUPPLY'
      | 'TYPE_SIGNER_THRESHOLD_SET'
      | 'TYPE_GOVERNANCE_VALIDATE_ASSET'
      | 'TYPE_ETHEREUM_CONTRACT_CALL_RESULT';
    /** Command to submit new oracle data from third party providers */
    readonly v1OracleDataSubmission: {
      /**
       * Format: byte
       * @description Data provided by the data source.
       */
      readonly payload?: string;
      /** @description Source from which the data is coming from. */
      readonly source?: components['schemas']['OracleDataSubmissionOracleSource'];
    };
    /**
     * @description A command that allows a party to update the details of an existing order.
     * Any field that is left unset or as a default value indicates that this field on the original order will be left unchanged.
     * It is not possible to change an order's type through this command.
     */
    readonly v1OrderAmendment: {
      /**
       * Format: int64
       * @description Timestamp, in Unix nanoseconds, for the new expiry time for the order.
       */
      readonly expiresAt?: string;
      /** @description Market ID that the order was originally submitted to. */
      readonly marketId?: string;
      /** @description ID of the order to amend. */
      readonly orderId?: string;
      /**
       * @description New pegged offset for the order.
       * This field is an unsigned integer scaled to the market's decimal places.
       */
      readonly peggedOffset?: string;
      /** @description New pegged reference for the order. */
      readonly peggedReference?: components['schemas']['vegaPeggedReference'];
      /** @description New price for the order. This field is an unsigned integer scaled to the market's decimal places. */
      readonly price?: string;
      /**
       * Format: int64
       * @description Amend the size for the order by the delta specified:
       * - To reduce the size from the current value set a negative integer value
       * - To increase the size from the current value, set a positive integer value
       * - To leave the size unchanged set a value of zero
       * This field needs to be scaled using the market's position decimal places.
       */
      readonly sizeDelta?: string;
      /** @description New time in force for the order. */
      readonly timeInForce?: components['schemas']['OrderTimeInForce'];
    };
    /**
     * @description A command that instructs the network to cancel orders, active or partially filled, that were previously submitted by the sender of this transaction.
     * It is not possible to cancel another party's order with this command.
     */
    readonly v1OrderCancellation: {
      /** @description Restrict cancellations to those submitted to the given market. If not set, all stop orders across all markets will be cancelled. */
      readonly marketId?: string;
      /** @description Restrict cancellations to an order with the given ID. If set, then a market ID must also be provided. */
      readonly orderId?: string;
    };
    /** @description A command that submits an order to the Vega network for a given market. */
    readonly v1OrderSubmission: {
      /**
       * Format: int64
       * @description Timestamp, in Unix nanoseconds, for when the order will expire. Can only be set when the order's time-in-force is GTT.
       */
      readonly expiresAt?: string;
      /** @description Iceberg order details. If set, the order will exist on the order book in chunks. */
      readonly icebergOpts?: components['schemas']['v1IcebergOpts'];
      /** @description Market ID to submit the order to. */
      readonly marketId?: string;
      /** @description Pegged order details. If set, the order's price will be offset from a particular reference price of the order book at all times. */
      readonly peggedOrder?: components['schemas']['vegaPeggedOrder'];
      /** @description If set, the order will only be executed if it would not trade on entry to the order book. Only valid for limit orders. */
      readonly postOnly?: boolean;
      /**
       * @description Price for the order, the price is an integer, for example `123456` is a correctly
       * formatted price of `1.23456` assuming market configured to 5 decimal places,
       * required field for limit orders, however it is not required for market orders.
       * This field is an unsigned integer scaled to the market's decimal places.
       */
      readonly price?: string;
      /**
       * @description If set, the order will only be executed if the outcome of the trade moves the trader's position closer to 0.
       * Only valid for non-persistent orders.
       */
      readonly reduceOnly?: boolean;
      /** @description Arbitrary optional reference for the order, to be used as a human-readable non-unique identifier for the order. */
      readonly reference?: string;
      /** @description Which side of the order book the order is for, e.g. buy or sell. */
      readonly side?: components['schemas']['vegaSide'];
      /**
       * Format: uint64
       * @description Size for the order, for example, in a futures market the size equals the number of units.
       */
      readonly size?: string;
      /** @description Time in force indicates how long an order will remain active before it is executed or expires.. */
      readonly timeInForce?: components['schemas']['OrderTimeInForce'];
      /** @description Type of the order. */
      readonly type?: components['schemas']['vegaOrderType'];
    };
    /** @description Components needed for the network to verify proof-of-work. */
    readonly v1ProofOfWork: {
      /**
       * Format: uint64
       * @description Number which, combined with the transaction identifier, will produce a hash with the required number of leading zeros to be accepted by the network.
       */
      readonly nonce?: string;
      /** @description Unique transaction identifier used to seed the proof-of-work hash. */
      readonly tid?: string;
    };
    /** @description PropertyKey describes the property key contained in data source data. */
    readonly v1PropertyKey: {
      /** @description Name of the property. */
      readonly name?: string;
      /**
       * Optional decimal place to be be applied on the provided value
       * valid only for PropertyType of type DECIMAL and INTEGER
       * Format: uint64
       */
      readonly numberDecimalPlaces?: string;
      /** @description Data type of the property. */
      readonly type?: components['schemas']['v1PropertyKeyType'];
    };
    /**
     * @description Type describes the data type of properties that are supported by the data source
     * engine.
     *
     *  - TYPE_UNSPECIFIED: The default value.
     *  - TYPE_EMPTY: Any type.
     *  - TYPE_INTEGER: Integer type.
     *  - TYPE_STRING: String type.
     *  - TYPE_BOOLEAN: Boolean type.
     *  - TYPE_DECIMAL: Any floating point decimal type.
     *  - TYPE_TIMESTAMP: Timestamp date type.
     * @default TYPE_UNSPECIFIED
     * @enum {string}
     */
    readonly v1PropertyKeyType:
      | 'TYPE_UNSPECIFIED'
      | 'TYPE_EMPTY'
      | 'TYPE_INTEGER'
      | 'TYPE_STRING'
      | 'TYPE_BOOLEAN'
      | 'TYPE_DECIMAL'
      | 'TYPE_TIMESTAMP';
    /**
     * @description Command that allows a token holder to submit a governance proposal that can be voted on by any other token holders, and eventually enacted on the Vega network.
     * For example this command can be used to propose a new market.
     */
    readonly v1ProposalSubmission: {
      /** @description Rationale behind a proposal. */
      readonly rationale?: components['schemas']['vegaProposalRationale'];
      /** @description Arbitrary human-readable reference identifying the proposal. */
      readonly reference?: string;
      /** @description Proposal terms containing the type and details of the proposal, as well as time spans for voting and enactment. */
      readonly terms?: components['schemas']['vegaProposalTerms'];
    };
    /** @description A validator command sent manually by a node operator to propose a protocol upgrade. */
    readonly v1ProtocolUpgradeProposal: {
      /**
       * Format: uint64
       * @description Block height at which to perform the upgrade.
       */
      readonly upgradeBlockHeight?: string;
      /** @description Release tag for the Vega binary. */
      readonly vegaReleaseTag?: string;
    };
    /**
     * @description PubKey is the public key that signed this data.
     * Different public keys coming from different sources will be further separated.
     */
    readonly v1PubKey: {
      readonly key?: string;
    };
    /** @description Signature definition that allows the network to authenticate external data. */
    readonly v1Signature: {
      /** @description Algorithm used to create the signature. */
      readonly algo?: string;
      /** @description Hex encoded bytes of the signature. */
      readonly value?: string;
      /**
       * Format: int64
       * @description Version of the algorithm used to create the signature.
       */
      readonly version?: number;
    };
    readonly v1Signer: {
      /** @description In case of an open oracle - Ethereum address will be submitted. */
      readonly ethAddress?: components['schemas']['v1ETHAddress'];
      /**
       * @description List of authorized public keys that signed the data for this
       * source. All the public keys in the data should be contained in these
       * public keys.
       */
      readonly pubKey?: components['schemas']['v1PubKey'];
    };
    /** @description A validator command sent automatically to reach consensus on floating point values. */
    readonly v1StateVariableProposal: {
      /** @description Details of the state variable being proposed. */
      readonly proposal?: components['schemas']['vegaStateValueProposal'];
    };
    /** @description Price and expiry configuration for a stop order. */
    readonly v1StopOrderSetup: {
      /**
       * Format: int64
       * @description Timestamp, in Unix nanoseconds, for when the stop order should expire. If not set the stop order will not expire.
       */
      readonly expiresAt?: string;
      /** @description Strategy to adopt if the expiry time is reached. */
      readonly expiryStrategy?: components['schemas']['StopOrderExpiryStrategy'];
      /** @description Order to be submitted once the trigger is breached. */
      readonly orderSubmission?: components['schemas']['v1OrderSubmission'];
      /** @description Order will be submitted if the last traded price on the market breaches the given price. */
      readonly price?: string;
      /** @description Order will be submitted if the last traded price has moved the given percent from the highest/lowest mark price since the stop order was submitted. */
      readonly trailingPercentOffset?: string;
    };
    /**
     * @description A command that instructs the network to cancel untriggered stop orders that were submitted by the sender of this transaction.
     * If any cancelled stop order is part of an OCO, both stop orders will be cancelled.
     * It is not possible to cancel another party's stop orders with this command.
     */
    readonly v1StopOrdersCancellation: {
      /** @description Restrict cancellations to those submitted to the given market. If not set, all stop orders across all markets will be cancelled. */
      readonly marketId?: string;
      /** @description Restrict cancellations to a stop order with the given ID. If set, then a market ID must also be provided. */
      readonly stopOrderId?: string;
    };
    /**
     * @description A command that allows a party to submit a stop order for a given market.
     * A stop order is a normal order that remains off the order book and is only submitted if a given trigger is breached from a particular direction.
     * If both rises-above and falls-below are configured, then if one is triggered the other will be cancelled (OCO).
     */
    readonly v1StopOrdersSubmission: {
      /** @description Stop order that will be triggered if the price falls below a given trigger price. */
      readonly fallsBelow?: components['schemas']['v1StopOrderSetup'];
      /** @description Stop order that will be triggered if the price rises above a given trigger price. */
      readonly risesAbove?: components['schemas']['v1StopOrderSetup'];
    };
    /**
     * @description Transaction versions to maintain backwards compatibility of transaction formats.
     *
     *  - TX_VERSION_UNSPECIFIED: Transaction version is unspecified.
     *  - TX_VERSION_V2: Transaction requires the addition of a proof-of-work calculation.
     *  - TX_VERSION_V3: Transaction input data contains a prepended chain ID to prevent use of a single transaction across multiple networks.
     * @default TX_VERSION_UNSPECIFIED
     * @enum {string}
     */
    readonly v1TxVersion:
      | 'TX_VERSION_UNSPECIFIED'
      | 'TX_VERSION_V2'
      | 'TX_VERSION_V3';
    /** @description Command to allow a token holder to instruct the network to remove their delegated stake from a given validator node. */
    readonly v1UndelegateSubmission: {
      /**
       * @description Amount to undelegate, as an unsigned integer scaled to the governance asset's decimal places.
       * If not set, then all delegations to the given validator node will be removed.
       */
      readonly amount?: string;
      /** @description Method of delegation. */
      readonly method?: components['schemas']['UndelegateSubmissionMethod'];
      /** @description Node ID to undelegate stake from. */
      readonly nodeId?: string;
    };
    /**
     * @description A command that allows the referrer of a referral set to update team details for a referral set.
     * Any field that is left unset or has a default value indicates that this field on the original referral set will be left unchanged.
     */
    readonly v1UpdateReferralSet: {
      /** @description ID of the referral set to update. */
      readonly id?: string;
      /** @description Whether or not the referral set should be considered a team that can participate in team games on the network. */
      readonly isTeam?: boolean;
      /** @description Team details, if the referral set is to be considered a team. */
      readonly team?: components['schemas']['v1UpdateReferralSetTeam'];
    };
    readonly v1UpdateReferralSetTeam: {
      /** @description New link to an avatar for the team. */
      readonly avatarUrl?: string;
      /** @description Whether or not the team is closed to new party members. */
      readonly closed?: boolean;
      /** @description New name of the team. */
      readonly name?: string;
      /** @description New link to the team's homepage. */
      readonly teamUrl?: string;
    };
    /**
     * @description A validator command which is sent automatically at regular intervals by any validator participating in the network.
     * It is used to allow the network to know whether a validator is active, or if they have shut down.
     */
    readonly v1ValidatorHeartbeat: {
      /** @description Signature from the validator made using their Ethereum wallet. */
      readonly ethereumSignature?: components['schemas']['v1Signature'];
      /** @description Message which has been signed. */
      readonly message?: string;
      /** @description Node ID of the validator emitting the heartbeat. */
      readonly nodeId?: string;
      /** @description Signature from the validator made using their Vega wallet. */
      readonly vegaSignature?: components['schemas']['v1Signature'];
    };
    /** @description Command that allows a token holder to vote for or against an active governance proposal. */
    readonly v1VoteSubmission: {
      /** @description Submit vote for the specified proposal ID. */
      readonly proposalId?: string;
      /** @description Actual value of the vote. */
      readonly value?: components['schemas']['vegaVoteValue'];
    };
    /**
     * @description Command to instruct the network to process an asset withdrawal from the Vega network.
     * The process is specific to the destination foreign chain, for example, a withdrawal to Ethereum will generate signatures
     * that allow funds to be taken across the bridge.
     */
    readonly v1WithdrawSubmission: {
      /** @description Amount to be withdrawn, as an unsigned integer scaled to the asset's decimal places. */
      readonly amount?: string;
      /** @description Asset to be withdrawn. */
      readonly asset?: string;
      /** @description Details specific to the foreign chain, such as the receiver address. */
      readonly ext?: components['schemas']['vegaWithdrawExt'];
    };
    /**
     * Various collateral/account types as used by Vega
     * @description - ACCOUNT_TYPE_UNSPECIFIED: Default value
     *  - ACCOUNT_TYPE_INSURANCE: Insurance pool accounts contain insurance pool funds for a market
     *  - ACCOUNT_TYPE_SETTLEMENT: Settlement accounts exist only during settlement or mark-to-market
     *  - ACCOUNT_TYPE_MARGIN: Margin accounts contain funds set aside for the margin needed to support a party's open positions.
     * Each party will have a margin account for each market they have traded in.
     * Required initial margin is allocated to each market from user's general account.
     * Collateral in the margin account can't be withdrawn or used as margin on another market until
     * it is released back to the general account.
     * Vega protocol uses an internal accounting system to segregate funds held as
     * margin from other funds to ensure they are never lost or 'double spent'
     *
     * Margin account funds will vary as margin requirements on positions change
     *  - ACCOUNT_TYPE_GENERAL: General accounts contain the collateral for a party that is not otherwise allocated. A party will
     * have multiple general accounts, one for each asset they want
     * to trade with
     *
     * General accounts are where funds are initially deposited or withdrawn from,
     * it is also the account where funds are taken to fulfil fees and initial margin requirements
     *  - ACCOUNT_TYPE_FEES_INFRASTRUCTURE: Infrastructure accounts contain fees earned by providing infrastructure on Vega
     *  - ACCOUNT_TYPE_FEES_LIQUIDITY: Liquidity accounts contain fees earned by providing liquidity on Vega markets
     *  - ACCOUNT_TYPE_FEES_MAKER: This account is created to hold fees earned by placing orders that sit on the book
     * and are then matched with an incoming order to create a trade - These fees reward parties
     * who provide the best priced liquidity that actually allows trading to take place
     *  - ACCOUNT_TYPE_BOND: This account is created to maintain liquidity providers funds commitments
     *  - ACCOUNT_TYPE_EXTERNAL: External account represents an external source (deposit/withdrawal)
     *  - ACCOUNT_TYPE_GLOBAL_INSURANCE: Global insurance account for the asset
     *  - ACCOUNT_TYPE_GLOBAL_REWARD: Global reward account for the asset
     *  - ACCOUNT_TYPE_PENDING_TRANSFERS: Per asset account used to store pending transfers (if any)
     *  - ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES: Per asset reward account for fees paid to makers
     *  - ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES: Per asset reward account for fees received by makers
     *  - ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES: Per asset reward account for fees received by liquidity providers
     *  - ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS: Per asset reward account for market proposers when the market goes above some trading threshold
     *  - ACCOUNT_TYPE_HOLDING: Per asset account for holding in-flight unfilled orders' funds
     *  - ACCOUNT_TYPE_LP_LIQUIDITY_FEES: Network controlled liquidity provider's account, per market, to hold accrued liquidity fees.
     *  - ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION: Network controlled liquidity fees bonus distribution account, per market.
     *  - ACCOUNT_TYPE_NETWORK_TREASURY: Network controlled treasury
     *  - ACCOUNT_TYPE_VESTING_REWARDS: Account holding user's rewards for the vesting period
     *  - ACCOUNT_TYPE_VESTED_REWARDS: Account holding user's rewards after the vesting period
     *  - ACCOUNT_TYPE_REWARD_AVERAGE_POSITION: Per asset market reward account given for average position
     *  - ACCOUNT_TYPE_REWARD_RELATIVE_RETURN: Per asset market reward account given for relative return
     *  - ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY: Per asset market reward account given for return volatility
     *  - ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING: Per asset market reward account given to validators by their ranking
     *  - ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD: Per asset account for pending fee referral reward payouts
     * @default ACCOUNT_TYPE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaAccountType:
      | 'ACCOUNT_TYPE_UNSPECIFIED'
      | 'ACCOUNT_TYPE_INSURANCE'
      | 'ACCOUNT_TYPE_SETTLEMENT'
      | 'ACCOUNT_TYPE_MARGIN'
      | 'ACCOUNT_TYPE_GENERAL'
      | 'ACCOUNT_TYPE_FEES_INFRASTRUCTURE'
      | 'ACCOUNT_TYPE_FEES_LIQUIDITY'
      | 'ACCOUNT_TYPE_FEES_MAKER'
      | 'ACCOUNT_TYPE_BOND'
      | 'ACCOUNT_TYPE_EXTERNAL'
      | 'ACCOUNT_TYPE_GLOBAL_INSURANCE'
      | 'ACCOUNT_TYPE_GLOBAL_REWARD'
      | 'ACCOUNT_TYPE_PENDING_TRANSFERS'
      | 'ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES'
      | 'ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES'
      | 'ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES'
      | 'ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS'
      | 'ACCOUNT_TYPE_HOLDING'
      | 'ACCOUNT_TYPE_LP_LIQUIDITY_FEES'
      | 'ACCOUNT_TYPE_LIQUIDITY_FEES_BONUS_DISTRIBUTION'
      | 'ACCOUNT_TYPE_NETWORK_TREASURY'
      | 'ACCOUNT_TYPE_VESTING_REWARDS'
      | 'ACCOUNT_TYPE_VESTED_REWARDS'
      | 'ACCOUNT_TYPE_REWARD_AVERAGE_POSITION'
      | 'ACCOUNT_TYPE_REWARD_RELATIVE_RETURN'
      | 'ACCOUNT_TYPE_REWARD_RETURN_VOLATILITY'
      | 'ACCOUNT_TYPE_REWARD_VALIDATOR_RANKING'
      | 'ACCOUNT_TYPE_PENDING_FEE_REFERRAL_REWARD';
    /** Vega representation of an external asset */
    readonly vegaAssetDetails: {
      /** @description Vega built-in asset. */
      readonly builtinAsset?: components['schemas']['vegaBuiltinAsset'];
      /**
       * Format: uint64
       * @description Number of decimal / precision handled by this asset.
       */
      readonly decimals?: string;
      /** @description Ethereum ERC20 asset. */
      readonly erc20?: components['schemas']['vegaERC20'];
      /** @description Name of the asset (e.g: Great British Pound). */
      readonly name?: string;
      /** @description Minimum economically meaningful amount in the asset. */
      readonly quantum?: string;
      /** @description Symbol of the asset (e.g: GBP). */
      readonly symbol?: string;
    };
    /** @description Changes to apply on an existing asset. */
    readonly vegaAssetDetailsUpdate: {
      /** @description Ethereum ERC20 asset update. */
      readonly erc20?: components['schemas']['vegaERC20Update'];
      /** @description Minimum economically meaningful amount in the asset. */
      readonly quantum?: string;
    };
    readonly vegaBenefitTier: {
      /**
       * @description Required number of epochs a party must have been in a referral set to
       * access this tier.
       */
      readonly minimumEpochs?: string;
      /**
       * @description Required running notional taker volume in quantum units for parties
       * to access this tier.
       */
      readonly minimumRunningNotionalTakerVolume?: string;
      /** @description Proportion of the referee's taker fees to be discounted. */
      readonly referralDiscountFactor?: string;
      /** @description Proportion of the referee's taker fees to be rewarded to the referrer. */
      readonly referralRewardFactor?: string;
    };
    /** Vega internal asset */
    readonly vegaBuiltinAsset: {
      /** @description Maximum amount that can be requested by a party through the built-in asset faucet at a time. */
      readonly maxFaucetAmountMint?: string;
    };
    /** Deposit for a Vega built-in asset */
    readonly vegaBuiltinAssetDeposit: {
      /** @description Amount to be deposited. This field is an unsigned integer scaled to the asset's decimal places. */
      readonly amount?: string;
      /** @description Vega party ID i.e. public key. */
      readonly partyId?: string;
      /** @description Vega network internal asset ID. */
      readonly vegaAssetId?: string;
    };
    /** Event related to a Vega built-in asset */
    readonly vegaBuiltinAssetEvent: {
      /** @description Built-in asset deposit. */
      readonly deposit?: components['schemas']['vegaBuiltinAssetDeposit'];
      /** @description Built-in asset withdrawal. */
      readonly withdrawal?: components['schemas']['vegaBuiltinAssetWithdrawal'];
    };
    /** Withdrawal for a Vega built-in asset */
    readonly vegaBuiltinAssetWithdrawal: {
      /** @description The amount to be withdrawn. This field is an unsigned integer scaled to the asset's decimal places. */
      readonly amount?: string;
      /** @description Vega network party ID i.e. public key. */
      readonly partyId?: string;
      /** @description Vega network internal asset ID. */
      readonly vegaAssetId?: string;
    };
    readonly vegaCancelTransfer: {
      /** Configuration for cancellation of a governance-initiated transfer */
      readonly changes?: components['schemas']['vegaCancelTransferConfiguration'];
    };
    readonly vegaCancelTransferConfiguration: {
      /** @description ID of the governance transfer proposal. */
      readonly transferId?: string;
    };
    /**
     * @description Represents the top level object that handles data sources.
     * Data source definition can be external or internal, with whatever
     * number of data sources are defined for each type in the child objects below.
     */
    readonly vegaDataSourceDefinition: {
      readonly external?: components['schemas']['vegaDataSourceDefinitionExternal'];
      readonly internal?: components['schemas']['vegaDataSourceDefinitionInternal'];
    };
    /**
     * @description DataSourceDefinitionExternal is the top level object used for all external
     * data sources. It contains one of any of the defined `SourceType` variants.
     */
    readonly vegaDataSourceDefinitionExternal: {
      /** @description Contains the data specification that is received from Ethereum sources. */
      readonly ethOracle?: components['schemas']['vegaEthCallSpec'];
      readonly oracle?: components['schemas']['vegaDataSourceSpecConfiguration'];
    };
    /**
     * @description Top level object used for all internal data sources.
     * It contains one of any of the defined source type variants.
     */
    readonly vegaDataSourceDefinitionInternal: {
      readonly time?: components['schemas']['vegaDataSourceSpecConfigurationTime'];
      readonly timeTrigger?: components['schemas']['vegaDataSourceSpecConfigurationTimeTrigger'];
    };
    /**
     * @description All types of external data sources use the same configuration set for meeting
     * requirements in order for the data to be useful for Vega - valid signatures
     * and matching filters.
     */
    readonly vegaDataSourceSpecConfiguration: {
      /**
       * @description Filters describes which source data are considered of interest or not for
       * the product (or the risk model).
       */
      readonly filters?: readonly components['schemas']['v1Filter'][];
      /**
       * @description Signers is the list of authorized signatures that signed the data for this
       * source. All the signatures in the data source data should be contained in
       * this external source. All the signatures in the data should be contained in
       * this list.
       */
      readonly signers?: readonly components['schemas']['v1Signer'][];
    };
    /** @description Internal data source used for emitting timestamps. */
    readonly vegaDataSourceSpecConfigurationTime: {
      /** @description Conditions that the timestamps should meet in order to be considered. */
      readonly conditions?: readonly components['schemas']['v1Condition'][];
    };
    /** @description Internal data source used for emitting timestamps automatically using predefined intervals and conditions. */
    readonly vegaDataSourceSpecConfigurationTimeTrigger: {
      /** @description Conditions that the timestamps need to meet in order to be considered. */
      readonly conditions?: readonly components['schemas']['v1Condition'][];
      /** An internal time trigger */
      readonly triggers?: readonly components['schemas']['v1InternalTimeTrigger'][];
    };
    /**
     * DataSourceSpecToFutureBinding describes which property of the data source data is to be
     * used as settlement data and which to use as the trading terminated trigger
     */
    readonly vegaDataSourceSpecToFutureBinding: {
      /**
       * @description Name of the property in the source data that should be used as settlement data.
       * If it is set to "prices.BTC.value", then the Future will use the value of
       * this property as settlement data.
       */
      readonly settlementDataProperty?: string;
      /** @description Name of the property in the data source data that signals termination of trading. */
      readonly tradingTerminationProperty?: string;
    };
    /**
     * Describes which property of the data source data is to be
     * used as settlement data and which to use as the trading terminated trigger
     */
    readonly vegaDataSourceSpecToPerpetualBinding: {
      /**
       * @description Name of the property in the source data that should be used as settlement data.
       * If it is set to "prices.BTC.value", then the perpetual market will use the value of
       * this property as settlement data.
       */
      readonly settlementDataProperty?: string;
      /**
       * @description Name of the property in the source data that should be used as settlement data.
       * If it is set to "prices.BTC.value", then the perpetual market will use the value of
       * this property as settlement data.
       */
      readonly settlementScheduleProperty?: string;
    };
    /**
     * - DISPATCH_METRIC_MAKER_FEES_PAID: Dispatch metric that uses the total maker fees paid in the market
     *  - DISPATCH_METRIC_MAKER_FEES_RECEIVED: Dispatch metric that uses the total maker fees received in the market
     *  - DISPATCH_METRIC_LP_FEES_RECEIVED: Dispatch metric that uses the total LP fees received in the market
     *  - DISPATCH_METRIC_MARKET_VALUE: Dispatch metric that uses total value of the market if above the required threshold and not paid given proposer bonus yet
     *  - DISPATCH_METRIC_AVERAGE_POSITION: Dispatch metric that uses the time weighted average position
     *  - DISPATCH_METRIC_RELATIVE_RETURN: Dispatch metric that uses the relative PNL of the party in the market
     *  - DISPATCH_METRIC_RETURN_VOLATILITY: Dispatch metric that uses return volatility of the party in the market
     *  - DISPATCH_METRIC_VALIDATOR_RANKING: Dispatch metric that uses the validator ranking of the validator as metric
     * @default DISPATCH_METRIC_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaDispatchMetric:
      | 'DISPATCH_METRIC_UNSPECIFIED'
      | 'DISPATCH_METRIC_MAKER_FEES_PAID'
      | 'DISPATCH_METRIC_MAKER_FEES_RECEIVED'
      | 'DISPATCH_METRIC_LP_FEES_RECEIVED'
      | 'DISPATCH_METRIC_MARKET_VALUE'
      | 'DISPATCH_METRIC_AVERAGE_POSITION'
      | 'DISPATCH_METRIC_RELATIVE_RETURN'
      | 'DISPATCH_METRIC_RETURN_VOLATILITY'
      | 'DISPATCH_METRIC_VALIDATOR_RANKING';
    readonly vegaDispatchStrategy: {
      /** @description Asset to use for metric. */
      readonly assetForMetric?: string;
      /** Controls how the reward is distributed between qualifying parties */
      readonly distributionStrategy?: components['schemas']['vegaDistributionStrategy'];
      /** @description Mandatory enum that defines the entities within scope. */
      readonly entityScope?: components['schemas']['vegaEntityScope'];
      /** @description Optional enum if the entity scope defined is for individuals, which determines the subset of individuals that are eligible to be rewarded. */
      readonly individualScope?: components['schemas']['vegaIndividualScope'];
      /**
       * Number of epochs after distribution to delay vesting of rewards by
       * Format: uint64
       */
      readonly lockPeriod?: string;
      /** @description Optional markets in scope. */
      readonly markets?: readonly string[];
      /** @description Metric to apply. */
      readonly metric?: components['schemas']['vegaDispatchMetric'];
      /** The proportion of the top performers in the team for a given metric to be averaged for the metric calculation if the scope is team */
      readonly nTopPerformers?: string;
      /** Minimum notional time-weighted averaged position required for a party to be considered eligible. Defaults to 0 */
      readonly notionalTimeWeightedAveragePositionRequirement?: string;
      /** @description Ordered list, using start rank, defining the rank bands and share ratio for each band. Mandatory for the rank distribution strategy. */
      readonly rankTable?: readonly components['schemas']['vegaRank'][];
      /** Minimum number of governance (e.g. VEGA) tokens staked for a party to be considered eligible. Defaults to 0 */
      readonly stakingRequirement?: string;
      /** Optional list applicable if the reward type has a scope of teams, which allows the funder to define a list of team IDs that are eligible to be rewarded from this transfer */
      readonly teamScope?: readonly string[];
      /**
       * Number of epochs to evaluate the metric on
       * Format: uint64
       */
      readonly windowLength?: string;
    };
    /**
     * @description  - DISTRIBUTION_STRATEGY_PRO_RATA: Rewards funded using the pro-rata strategy should be distributed pro-rata by each entity's reward metric, scaled by any active multipliers that party has.
     *  - DISTRIBUTION_STRATEGY_RANK: Rewards funded using the party rank.
     * @default DISTRIBUTION_STRATEGY_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaDistributionStrategy:
      | 'DISTRIBUTION_STRATEGY_UNSPECIFIED'
      | 'DISTRIBUTION_STRATEGY_PRO_RATA'
      | 'DISTRIBUTION_STRATEGY_RANK';
    /** ERC20 token based asset, living on the ethereum network */
    readonly vegaERC20: {
      /** @description Address of the contract for the token, on the ethereum network. */
      readonly contractAddress?: string;
      /**
       * @description Lifetime limits deposit per address
       * note: this is a temporary measure that can be changed by governance.
       */
      readonly lifetimeLimit?: string;
      /**
       * @description Maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.
       * Theres no limit on the size of a withdrawal
       * note: this is a temporary measure that can be changed by governance.
       */
      readonly withdrawThreshold?: string;
    };
    /** Asset deny-listing for an ERC20 token */
    readonly vegaERC20AssetDelist: {
      /** @description Vega network internal asset ID. */
      readonly vegaAssetId?: string;
    };
    readonly vegaERC20AssetLimitsUpdated: {
      /** @description Updated lifetime limits. */
      readonly lifetimeLimits?: string;
      /** @description Ethereum wallet that initiated the deposit. */
      readonly sourceEthereumAddress?: string;
      /** @description Vega network internal asset ID. */
      readonly vegaAssetId?: string;
      /** @description Updated withdrawal threshold. */
      readonly withdrawThreshold?: string;
    };
    /** Asset allow-listing for an ERC20 token */
    readonly vegaERC20AssetList: {
      /** @description Ethereum address of the asset. */
      readonly assetSource?: string;
      /** @description Vega network internal asset ID. */
      readonly vegaAssetId?: string;
    };
    /** Asset deposit for an ERC20 token */
    readonly vegaERC20Deposit: {
      /** @description Amount to be deposited. */
      readonly amount?: string;
      /** @description Ethereum wallet that initiated the deposit. */
      readonly sourceEthereumAddress?: string;
      /** @description Vega party ID i.e. public key that is the target of the deposit. */
      readonly targetPartyId?: string;
      /** @description Vega network internal asset ID. */
      readonly vegaAssetId?: string;
    };
    /** Event related to an ERC20 token */
    readonly vegaERC20Event: {
      /** @description De-list an ERC20 asset. */
      readonly assetDelist?: components['schemas']['vegaERC20AssetDelist'];
      /** @description Update an ERC20 asset. */
      readonly assetLimitsUpdated?: components['schemas']['vegaERC20AssetLimitsUpdated'];
      /** @description List an ERC20 asset. */
      readonly assetList?: components['schemas']['vegaERC20AssetList'];
      /**
       * Format: uint64
       * @description Block in which the transaction was added.
       */
      readonly block?: string;
      /** @description Bridge operations has been resumed. */
      readonly bridgeResumed?: boolean;
      /** @description Bridge operations has been stopped. */
      readonly bridgeStopped?: boolean;
      /** @description Deposit ERC20 asset. */
      readonly deposit?: components['schemas']['vegaERC20Deposit'];
      /**
       * Format: uint64
       * @description Index of the log in the transaction.
       */
      readonly index?: string;
      /** @description Withdraw ERC20 asset. */
      readonly withdrawal?: components['schemas']['vegaERC20Withdrawal'];
    };
    /** Event related to the ERC20 MultiSig */
    readonly vegaERC20MultiSigEvent: {
      /**
       * Block in which the transaction was added
       * Format: uint64
       */
      readonly block?: string;
      /**
       * Index of the log in the transaction
       * Format: uint64
       */
      readonly index?: string;
      /** Add a signer to the erc20 bridge */
      readonly signerAdded?: components['schemas']['vegaERC20SignerAdded'];
      /** Remove a signer from the erc20 bridge */
      readonly signerRemoved?: components['schemas']['vegaERC20SignerRemoved'];
      /** Threshold set */
      readonly thresholdSet?: components['schemas']['vegaERC20ThresholdSet'];
    };
    /** New signer added to the ERC20 bridge */
    readonly vegaERC20SignerAdded: {
      /**
       * Format: int64
       * @description Time at which the block was produced
       * will be used to inform the core at what time
       * the stake was made unavailable.
       */
      readonly blockTime?: string;
      /** Ethereum address of the new signer */
      readonly newSigner?: string;
      /** Nonce created by the Vega network used for this new signer */
      readonly nonce?: string;
    };
    /** Signer removed from the ERC20 bridge */
    readonly vegaERC20SignerRemoved: {
      /**
       * Format: int64
       * @description Time at which the block was produced.
       * Will be used to inform the core at what time
       * the stake was made unavailable.
       */
      readonly blockTime?: string;
      /** Nonce created by the Vega network used for this old signer */
      readonly nonce?: string;
      /** Ethereum address of the old signer */
      readonly oldSigner?: string;
    };
    /** Threshold has been updated on the multisig control */
    readonly vegaERC20ThresholdSet: {
      /**
       * Format: int64
       * @description Time at which the block was produced.
       * Will be used to inform the core at what time
       * the stake was made unavailable.
       */
      readonly blockTime?: string;
      /**
       * New threshold value to set
       * Format: int64
       */
      readonly newThreshold?: number;
      /** Nonce created by the Vega network */
      readonly nonce?: string;
    };
    readonly vegaERC20Update: {
      /**
       * @description Lifetime limits deposit per address.
       * This will be interpreted against the asset decimals.
       * note: this is a temporary measure that can be changed by governance.
       */
      readonly lifetimeLimit?: string;
      /**
       * @description Maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.
       * Theres no limit on the size of a withdrawal
       * note: this is a temporary measure that can be changed by governance.
       */
      readonly withdrawThreshold?: string;
    };
    /** Asset withdrawal for an ERC20 token */
    readonly vegaERC20Withdrawal: {
      /** @description Reference nonce used for the transaction. */
      readonly referenceNonce?: string;
      /** @description Target Ethereum wallet address. */
      readonly targetEthereumAddress?: string;
      /** @description Vega network internal asset ID. */
      readonly vegaAssetId?: string;
    };
    /**
     * - ENTITY_SCOPE_INDIVIDUALS: Rewards must be distributed directly to eligible parties.
     *  - ENTITY_SCOPE_TEAMS: Rewards must be distributed to directly eligible teams, and then amongst team members
     * @default ENTITY_SCOPE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaEntityScope:
      | 'ENTITY_SCOPE_UNSPECIFIED'
      | 'ENTITY_SCOPE_INDIVIDUALS'
      | 'ENTITY_SCOPE_TEAMS';
    /** Extension of data required for the withdraw submissions */
    readonly vegaErc20WithdrawExt: {
      /** @description Address into which the bridge will release the funds. */
      readonly receiverAddress?: string;
    };
    /**
     * @description Specifies a data source that derives its content from calling a read method
     * on an Ethereum contract.
     */
    readonly vegaEthCallSpec: {
      /** @description The ABI of that contract. */
      readonly abi?: string;
      /** @description Ethereum address of the contract to call. */
      readonly address?: string;
      /**
       * @description List of arguments to pass to method call.
       * Protobuf 'Value' wraps an arbitrary JSON type that is mapped to an Ethereum
       * type according to the ABI.
       */
      readonly args?: readonly Record<string, never>[];
      /** Filters the data returned from the contract method */
      readonly filters?: readonly components['schemas']['v1Filter'][];
      /** @description Name of the method on the contract to call. */
      readonly method?: string;
      /**
       * @description Normalisers are used to convert the data returned from the contract method
       * into a standard format. The key of the map is the name of the property,
       * which identifies the specific piece of data to other parts of the data
       * sourcing framework, for example filters. The value is a JSONPath expression
       * for expressing where in the contract call result the required data is
       * located, for example $[0] indicates the first result. $[1].price would look
       * in the second result returned from the contract for a structure with a key
       * called 'price' and use that if it exists.
       */
      readonly normalisers?: readonly components['schemas']['vegaNormaliser'][];
      /**
       * Number of confirmations required before the query is considered verified
       * Format: uint64
       */
      readonly requiredConfirmations?: string;
      /** @description Conditions for determining when to call the contract method. */
      readonly trigger?: components['schemas']['vegaEthCallTrigger'];
    };
    /** @description Determines when the contract method should be called. */
    readonly vegaEthCallTrigger: {
      readonly timeTrigger?: components['schemas']['vegaEthTimeTrigger'];
    };
    /** Result of calling an arbitrary Ethereum contract method */
    readonly vegaEthContractCallEvent: {
      /**
       * Format: uint64
       * @description Ethereum block height.
       */
      readonly blockHeight?: string;
      /**
       * Format: uint64
       * @description Ethereum block time in Unix seconds.
       */
      readonly blockTime?: string;
      /** @description Error message if the call failed. */
      readonly error?: string;
      /**
       * Format: byte
       * @description Result of contract call, packed according to the ABI stored in the associated data source spec.
       */
      readonly result?: string;
      /** @description ID of the data source spec that triggered this contract call. */
      readonly specId?: string;
    };
    /**
     * @description Trigger for an Ethereum call based on the Ethereum block timestamp. Can be
     * one-off or repeating.
     */
    readonly vegaEthTimeTrigger: {
      /**
       * Format: uint64
       * @description Repeat the call every n seconds after the initial call. If no time for
       * initial call was specified, begin repeating immediately.
       */
      readonly every?: string;
      /**
       * Format: uint64
       * @description Trigger when the Ethereum time is greater or equal to this time, in Unix
       * seconds.
       */
      readonly initial?: string;
      /**
       * Format: uint64
       * @description If repeating, stop once Ethereum time is greater than this time, in Unix
       * seconds. If not set, then repeat indefinitely.
       */
      readonly until?: string;
    };
    /** Future product configuration */
    readonly vegaFutureProduct: {
      /** @description Binding between the data source spec and the settlement data. */
      readonly dataSourceSpecBinding?: components['schemas']['vegaDataSourceSpecToFutureBinding'];
      /** @description Data source spec describing the data source for settlement. */
      readonly dataSourceSpecForSettlementData?: components['schemas']['vegaDataSourceDefinition'];
      /** @description The external data source spec describing the data source of trading termination. */
      readonly dataSourceSpecForTradingTermination?: components['schemas']['vegaDataSourceDefinition'];
      /** @description Product quote name. */
      readonly quoteName?: string;
      /** @description Asset ID for the product's settlement asset. */
      readonly settlementAsset?: string;
    };
    /**
     * @default GOVERNANCE_TRANSFER_TYPE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaGovernanceTransferType:
      | 'GOVERNANCE_TRANSFER_TYPE_UNSPECIFIED'
      | 'GOVERNANCE_TRANSFER_TYPE_ALL_OR_NOTHING'
      | 'GOVERNANCE_TRANSFER_TYPE_BEST_EFFORT';
    /**
     * @description  - INDIVIDUAL_SCOPE_ALL: All parties on the network are within the scope of this reward.
     *  - INDIVIDUAL_SCOPE_IN_TEAM: All parties that are part of a team are within the scope of this reward.
     *  - INDIVIDUAL_SCOPE_NOT_IN_TEAM: All parties that are not part of a team are within the scope of this reward.
     * @default INDIVIDUAL_SCOPE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaIndividualScope:
      | 'INDIVIDUAL_SCOPE_UNSPECIFIED'
      | 'INDIVIDUAL_SCOPE_ALL'
      | 'INDIVIDUAL_SCOPE_IN_TEAM'
      | 'INDIVIDUAL_SCOPE_NOT_IN_TEAM';
    /** Instrument configuration */
    readonly vegaInstrumentConfiguration: {
      /** @description Instrument code, human-readable shortcode used to describe the instrument. */
      readonly code?: string;
      /** @description Future. */
      readonly future?: components['schemas']['vegaFutureProduct'];
      /** @description Instrument name. */
      readonly name?: string;
      /** @description Perpetual. */
      readonly perpetual?: components['schemas']['vegaPerpetualProduct'];
      /** @description Spot. */
      readonly spot?: components['schemas']['vegaSpotProduct'];
    };
    readonly vegaKeyValueBundle: {
      readonly key?: string;
      readonly tolerance?: string;
      readonly value?: components['schemas']['vegaStateVarValue'];
    };
    /** LiquidityMonitoringParameters contains settings used for liquidity monitoring */
    readonly vegaLiquidityMonitoringParameters: {
      /**
       * Format: int64
       * @description Specifies by how many seconds an auction should be extended if leaving the auction were to trigger a liquidity auction.
       */
      readonly auctionExtension?: string;
      /** @description Specifies parameters related to target stake calculation. */
      readonly targetStakeParameters?: components['schemas']['vegaTargetStakeParameters'];
      /** @description Specifies the triggering ratio for entering liquidity auction. */
      readonly triggeringRatio?: string;
    };
    readonly vegaLiquiditySLAParameters: {
      /** @description Specifies the minimum fraction of time LPs must spend "on the book" providing their committed liquidity. */
      readonly commitmentMinTimeFraction?: string;
      /**
       * Format: uint64
       * @description Specifies the number of liquidity epochs over which past performance will continue to affect rewards.
       */
      readonly performanceHysteresisEpochs?: string;
      readonly priceRange?: string;
      /**
       * @description Specifies the maximum fraction of their accrued fees an LP that meets the SLA implied by market.liquidity.commitmentMinTimeFraction will lose to liquidity providers
       * that achieved a higher SLA performance than them.
       */
      readonly slaCompetitionFactor?: string;
    };
    /** Risk model parameters for log normal */
    readonly vegaLogNormalModelParams: {
      /**
       * Format: double
       * @description Mu parameter, annualised growth rate of the underlying asset.
       */
      readonly mu?: number;
      /**
       * Format: double
       * @description R parameter, annualised growth rate of the risk-free asset, used for discounting of future cash flows, can be any real number.
       */
      readonly r?: number;
      /**
       * Format: double
       * @description Sigma parameter, annualised volatility of the underlying asset, must be a strictly non-negative real number.
       */
      readonly sigma?: number;
    };
    /** Risk model for log normal */
    readonly vegaLogNormalRiskModel: {
      /** @description Risk model parameters for log normal. */
      readonly params?: components['schemas']['vegaLogNormalModelParams'];
      /**
       * Format: double
       * @description Risk Aversion Parameter.
       */
      readonly riskAversionParameter?: number;
      /**
       * Format: double
       * @description Tau parameter of the risk model, projection horizon measured as a year fraction used in the expected shortfall
       * calculation to obtain the maintenance margin, must be a strictly non-negative real number.
       */
      readonly tau?: number;
    };
    /**
     * - MARKET_STATE_UPDATE_TYPE_UNSPECIFIED: Default value, always invalid
     *  - MARKET_STATE_UPDATE_TYPE_TERMINATE: Request to terminate a market via governance
     *  - MARKET_STATE_UPDATE_TYPE_SUSPEND: Request to suspend a market via governance
     *  - MARKET_STATE_UPDATE_TYPE_RESUME: Request to resume a market via governance
     * @default MARKET_STATE_UPDATE_TYPE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaMarketStateUpdateType:
      | 'MARKET_STATE_UPDATE_TYPE_UNSPECIFIED'
      | 'MARKET_STATE_UPDATE_TYPE_TERMINATE'
      | 'MARKET_STATE_UPDATE_TYPE_SUSPEND'
      | 'MARKET_STATE_UPDATE_TYPE_RESUME';
    readonly vegaMatrixValue: {
      readonly value?: readonly components['schemas']['vegaVectorValue'][];
    };
    /** Represents a network parameter on Vega */
    readonly vegaNetworkParameter: {
      /** @description Unique key of the network parameter. */
      readonly key?: string;
      /** @description Value for the network parameter. */
      readonly value?: string;
    };
    /** New asset on Vega */
    readonly vegaNewAsset: {
      /** @description Configuration of the new asset. */
      readonly changes?: components['schemas']['vegaAssetDetails'];
    };
    /**
     * @description Freeform proposal
     * This message is just used as a placeholder to sort out the nature of the
     * proposal once parsed.
     */
    readonly vegaNewFreeform: Record<string, never>;
    /** New market on Vega */
    readonly vegaNewMarket: {
      /** @description Configuration of the new market. */
      readonly changes?: components['schemas']['vegaNewMarketConfiguration'];
    };
    /** Configuration for a new futures market on Vega */
    readonly vegaNewMarketConfiguration: {
      /**
       * Format: uint64
       * @description Decimal places used for the new futures market, sets the smallest price increment on the book.
       */
      readonly decimalPlaces?: string;
      /** @description New futures market instrument configuration. */
      readonly instrument?: components['schemas']['vegaInstrumentConfiguration'];
      /** @description Linear slippage factor is used to cap the slippage component of maintenance margin - it is applied to the slippage volume. */
      readonly linearSlippageFactor?: string;
      /** @description Liquidity monitoring parameters. */
      readonly liquidityMonitoringParameters?: components['schemas']['vegaLiquidityMonitoringParameters'];
      /** Liquidity SLA parameters */
      readonly liquiditySlaParameters?: components['schemas']['vegaLiquiditySLAParameters'];
      /** @description Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected. */
      readonly logNormal?: components['schemas']['vegaLogNormalRiskModel'];
      /**
       * @description DEPRECATED: Use liquidity SLA parameters instead.
       * Percentage move up and down from the mid price which specifies the range of
       * price levels over which automated liquidity provisions will be deployed.
       */
      readonly lpPriceRange?: string;
      /** @description Optional new futures market metadata, tags. */
      readonly metadata?: readonly string[];
      /**
       * Format: int64
       * @description Decimal places for order sizes, sets what size the smallest order / position on the futures market can be.
       */
      readonly positionDecimalPlaces?: string;
      /** @description Price monitoring parameters. */
      readonly priceMonitoringParameters?: components['schemas']['vegaPriceMonitoringParameters'];
      /** @description Simple risk model parameters, valid only if MODEL_SIMPLE is selected. */
      readonly simple?: components['schemas']['vegaSimpleModelParams'];
      /** @description Successor configuration. If this proposal is meant to succeed a given market, then this should be set. */
      readonly successor?: components['schemas']['vegaSuccessorConfiguration'];
    };
    /** New spot market on Vega */
    readonly vegaNewSpotMarket: {
      /** @description Configuration of the new spot market. */
      readonly changes?: components['schemas']['vegaNewSpotMarketConfiguration'];
    };
    /** Configuration for a new spot market on Vega */
    readonly vegaNewSpotMarketConfiguration: {
      /**
       * Format: uint64
       * @description Decimal places used for the new spot market, sets the smallest price increment on the book.
       */
      readonly decimalPlaces?: string;
      /** @description New spot market instrument configuration. */
      readonly instrument?: components['schemas']['vegaInstrumentConfiguration'];
      /** @description Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected. */
      readonly logNormal?: components['schemas']['vegaLogNormalRiskModel'];
      /** @description Optional new spot market metadata, tags. */
      readonly metadata?: readonly string[];
      /**
       * Format: int64
       * @description Decimal places for order sizes, sets what size the smallest order / position on the spot market can be.
       */
      readonly positionDecimalPlaces?: string;
      /** @description Price monitoring parameters. */
      readonly priceMonitoringParameters?: components['schemas']['vegaPriceMonitoringParameters'];
      /** @description Simple risk model parameters, valid only if MODEL_SIMPLE is selected. */
      readonly simple?: components['schemas']['vegaSimpleModelParams'];
      /** @description Specifies the liquidity provision SLA parameters. */
      readonly slaParams?: components['schemas']['vegaLiquiditySLAParameters'];
      /** @description Specifies parameters related to target stake calculation. */
      readonly targetStakeParameters?: components['schemas']['vegaTargetStakeParameters'];
    };
    /** New governance transfer */
    readonly vegaNewTransfer: {
      /** @description Configuration for a new transfer. */
      readonly changes?: components['schemas']['vegaNewTransferConfiguration'];
    };
    readonly vegaNewTransferConfiguration: {
      /** Maximum amount to transfer */
      readonly amount?: string;
      /** ID of asset to transfer */
      readonly asset?: string;
      /**
       * Specifies the account to transfer to, depending on the account type:
       * Network treasury: leave empty
       * Party: party's public key
       * Market insurance pool: market ID
       */
      readonly destination?: string;
      /** Specifies the account type to transfer to: reward pool, party, network insurance pool, market insurance pool */
      readonly destinationType?: components['schemas']['vegaAccountType'];
      /** Maximum fraction of the source account's balance to transfer as a decimal - i.e. 0.1 = 10% of the balance */
      readonly fractionOfBalance?: string;
      readonly oneOff?: components['schemas']['vegaOneOffTransfer'];
      readonly recurring?: components['schemas']['vegaRecurringTransfer'];
      /** If network treasury, field is empty, otherwise uses the market ID */
      readonly source?: string;
      /** Source account type, such as network treasury, market insurance pool */
      readonly sourceType?: components['schemas']['vegaAccountType'];
      /**
       * "All or nothing" or "best effort":
       * All or nothing: Transfers the specified amount or does not transfer anything
       * Best effort: Transfers the specified amount or the max allowable amount if this is less than the specified amount
       */
      readonly transferType?: components['schemas']['vegaGovernanceTransferType'];
    };
    readonly vegaNormaliser: {
      readonly expression?: string;
      readonly name?: string;
    };
    /** Specific details for a one off transfer */
    readonly vegaOneOffTransfer: {
      /**
       * Format: int64
       * @description Timestamp in Unix nanoseconds for when the transfer should be delivered into the receiver's account.
       */
      readonly deliverOn?: string;
    };
    /**
     * Type values for an order
     * @description - TYPE_UNSPECIFIED: Default value, always invalid
     *  - TYPE_LIMIT: Used for Limit orders
     *  - TYPE_MARKET: Used for Market orders
     *  - TYPE_NETWORK: Used for orders where the initiating party is the network (with distressed parties)
     * @default TYPE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaOrderType:
      | 'TYPE_UNSPECIFIED'
      | 'TYPE_LIMIT'
      | 'TYPE_MARKET'
      | 'TYPE_NETWORK';
    /**
     * Pegged orders are limit orders where the price is specified in the form REFERENCE +/- OFFSET
     * They can be used for any limit order that is valid during continuous trading
     */
    readonly vegaPeggedOrder: {
      /** @description Offset from the price reference. */
      readonly offset?: string;
      /** @description Price point the order is linked to. */
      readonly reference?: components['schemas']['vegaPeggedReference'];
    };
    /**
     * Pegged reference defines which price point a pegged order is linked to - meaning
     * the price for a pegged order is calculated from the value of the reference price point
     * @description - PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given
     *  - PEGGED_REFERENCE_MID: Mid price reference
     *  - PEGGED_REFERENCE_BEST_BID: Best bid price reference
     *  - PEGGED_REFERENCE_BEST_ASK: Best ask price reference
     * @default PEGGED_REFERENCE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaPeggedReference:
      | 'PEGGED_REFERENCE_UNSPECIFIED'
      | 'PEGGED_REFERENCE_MID'
      | 'PEGGED_REFERENCE_BEST_BID'
      | 'PEGGED_REFERENCE_BEST_ASK';
    /** Perpetual product configuration */
    readonly vegaPerpetualProduct: {
      /** @description Lower bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1]. */
      readonly clampLowerBound?: string;
      /** @description Upper bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1]. */
      readonly clampUpperBound?: string;
      /** @description Binding between the data source spec and the settlement data. */
      readonly dataSourceSpecBinding?: components['schemas']['vegaDataSourceSpecToPerpetualBinding'];
      /** @description Data source spec describing the data source for settlement. */
      readonly dataSourceSpecForSettlementData?: components['schemas']['vegaDataSourceDefinition'];
      /** @description Data source spec describing the data source for settlement schedule. */
      readonly dataSourceSpecForSettlementSchedule?: components['schemas']['vegaDataSourceDefinition'];
      /** @description Continuously compounded interest rate used in funding rate calculation, in the range [-1, 1]. */
      readonly interestRate?: string;
      /** @description Controls how much the upcoming funding payment liability contributes to party's margin, in the range [0, 1]. */
      readonly marginFundingFactor?: string;
      /** @description Product quote name. */
      readonly quoteName?: string;
      /** @description Asset ID for the product's settlement asset. */
      readonly settlementAsset?: string;
    };
    /** PriceMonitoringParameters contains a collection of triggers to be used for a given market */
    readonly vegaPriceMonitoringParameters: {
      readonly triggers?: readonly components['schemas']['vegaPriceMonitoringTrigger'][];
    };
    /** PriceMonitoringTrigger holds together price projection horizon , probability level p, and auction extension duration */
    readonly vegaPriceMonitoringTrigger: {
      /**
       * Format: int64
       * @description Price monitoring auction extension duration in seconds should the price
       * breach its theoretical level over the specified horizon at the specified
       * probability level.
       */
      readonly auctionExtension?: string;
      /**
       * Format: int64
       * @description Price monitoring projection horizon  in seconds.
       */
      readonly horizon?: string;
      /** @description Price monitoring probability level p. */
      readonly probability?: string;
    };
    /** @description Rationale behind a proposal. */
    readonly vegaProposalRationale: {
      /**
       * @description Description to show a short title / something in case the link goes offline.
       * This is to be between 0 and 20k unicode characters.
       * This is mandatory for all proposals.
       */
      readonly description?: string;
      /**
       * @description Title to be used to give a short description of the proposal in lists.
       * This is to be between 0 and 100 unicode characters.
       * This is mandatory for all proposals.
       */
      readonly title?: string;
    };
    /** Terms for a governance proposal on Vega */
    readonly vegaProposalTerms: {
      /** @description Cancel a governance transfer. */
      readonly cancelTransfer?: components['schemas']['vegaCancelTransfer'];
      /**
       * Format: int64
       * @description Timestamp as Unix time in seconds when voting closes for this proposal,
       * constrained by `minClose` and `maxClose` network parameters.
       */
      readonly closingTimestamp?: string;
      /**
       * Format: int64
       * @description Timestamp as Unix time in seconds when proposal gets enacted if passed,
       * constrained by `minEnact` and `maxEnact` network parameters.
       */
      readonly enactmentTimestamp?: string;
      /** @description Proposal change for creating new assets on Vega. */
      readonly newAsset?: components['schemas']['vegaNewAsset'];
      /**
       * @description Proposal change for a freeform request, which can be voted on but does not change the behaviour of the system,
       * and can be used to gauge community sentiment.
       */
      readonly newFreeform?: components['schemas']['vegaNewFreeform'];
      /** @description Proposal change for creating new futures market on Vega. */
      readonly newMarket?: components['schemas']['vegaNewMarket'];
      /** @description Proposal change for creating new spot market on Vega. */
      readonly newSpotMarket?: components['schemas']['vegaNewSpotMarket'];
      /** @description Proposal change for a governance transfer. */
      readonly newTransfer?: components['schemas']['vegaNewTransfer'];
      /** @description Proposal change for updating an asset. */
      readonly updateAsset?: components['schemas']['vegaUpdateAsset'];
      /** @description Proposal change for modifying an existing futures market on Vega. */
      readonly updateMarket?: components['schemas']['vegaUpdateMarket'];
      /** @description Proposal change for updating the state of a market. */
      readonly updateMarketState?: components['schemas']['vegaUpdateMarketState'];
      /** @description Proposal change for updating Vega network parameters. */
      readonly updateNetworkParameter?: components['schemas']['vegaUpdateNetworkParameter'];
      /** @description Proposal change for updating the referral program. */
      readonly updateReferralProgram?: components['schemas']['vegaUpdateReferralProgram'];
      /** @description Proposal change for modifying an existing spot market on Vega. */
      readonly updateSpotMarket?: components['schemas']['vegaUpdateSpotMarket'];
      /** @description Proposal change for updating the volume discount program. */
      readonly updateVolumeDiscountProgram?: components['schemas']['vegaUpdateVolumeDiscountProgram'];
      /**
       * Format: int64
       * @description Validation timestamp as Unix time in seconds.
       */
      readonly validationTimestamp?: string;
    };
    readonly vegaRank: {
      /** Format: int64 */
      readonly shareRatio?: number;
      /** Format: int64 */
      readonly startRank?: number;
    };
    /** Specific details for a recurring transfer */
    readonly vegaRecurringTransfer: {
      /** @description Optional parameter defining how a transfer is dispatched. */
      readonly dispatchStrategy?: components['schemas']['vegaDispatchStrategy'];
      /**
       * Format: uint64
       * @description Last epoch at which this transfer shall be paid.
       */
      readonly endEpoch?: string;
      /** Format: uint64 */
      readonly startEpoch?: string;
    };
    readonly vegaReferralProgramChanges: {
      /**
       * @description Defined benefit tiers in increasing order. First element will give Tier 1,
       * second element will give Tier 2, and so on. Determines the level of
       * benefit a party can expect based on performance criteria.
       */
      readonly benefitTiers?: readonly components['schemas']['vegaBenefitTier'][];
      /**
       * Format: int64
       * @description Timestamp as Unix time in seconds, after which when the current epoch
       * ends, the program will end and benefits will be disabled.
       */
      readonly endOfProgramTimestamp?: string;
      /**
       * @description Defined staking tiers in increasing order. First element will give Tier 1,
       * second element will give Tier 2, and so on. Determines the level of
       * benefit a party can expect based on their staking.
       */
      readonly stakingTiers?: readonly components['schemas']['vegaStakingTier'][];
      /**
       * Format: uint64
       * @description Number of epochs over which to evaluate a referral set's running volume.
       */
      readonly windowLength?: string;
    };
    readonly vegaScalarValue: {
      readonly value?: string;
    };
    /**
     * Side relates to the direction of an order, to Buy, or Sell
     * @description - SIDE_UNSPECIFIED: Default value, always invalid
     *  - SIDE_BUY: Buy order
     *  - SIDE_SELL: Sell order
     * @default SIDE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaSide: 'SIDE_UNSPECIFIED' | 'SIDE_BUY' | 'SIDE_SELL';
    /** Risk model parameters for simple modelling */
    readonly vegaSimpleModelParams: {
      /**
       * Format: double
       * @description Pre-defined risk factor value for long.
       */
      readonly factorLong?: number;
      /**
       * Format: double
       * @description Pre-defined risk factor value for short.
       */
      readonly factorShort?: number;
      /**
       * Format: double
       * @description Pre-defined maximum price move up that the model considers as valid.
       */
      readonly maxMoveUp?: number;
      /**
       * Format: double
       * @description Pre-defined minimum price move down that the model considers as valid.
       */
      readonly minMoveDown?: number;
      /**
       * Format: double
       * @description Pre-defined constant probability of trading.
       */
      readonly probabilityOfTrading?: number;
    };
    /** Spot product configuration */
    readonly vegaSpotProduct: {
      /** @description Base asset ID. */
      readonly baseAsset?: string;
      /** @description Product name. */
      readonly name?: string;
      /** @description Quote asset ID. */
      readonly quoteAsset?: string;
    };
    readonly vegaStakeDeposited: {
      /** @description Amount deposited as an unsigned base 10 integer scaled to the asset's decimal places. */
      readonly amount?: string;
      /**
       * Format: int64
       * @description Time at which the block was produced.
       * Will be used to inform the core at what time
       * the stake started to be available.
       */
      readonly blockTime?: string;
      /** Ethereum Address of the user depositing stake (hex encode with 0x prefix) */
      readonly ethereumAddress?: string;
      /** @description Hex encoded public key of the party receiving the stake deposit. */
      readonly vegaPublicKey?: string;
    };
    readonly vegaStakeRemoved: {
      /** @description Amount removed as a base 10 unsigned integer scaled to the asset's decimal places. */
      readonly amount?: string;
      /**
       * Format: int64
       * @description The time at which the block was produced
       * will be used to inform the core at what time
       * the stake was made unavailable.
       */
      readonly blockTime?: string;
      /** @description Ethereum address of the user removing stake. This should be hex encoded with 0x prefix. */
      readonly ethereumAddress?: string;
      /** @description Hex encoded public key of the party from which to remove stake. */
      readonly vegaPublicKey?: string;
    };
    readonly vegaStakeTotalSupply: {
      /** Address of the staking asset */
      readonly tokenAddress?: string;
      /** @description Total supply observed for the token as an unsigned based 10 integer scaled to the asset's decimal places. */
      readonly totalSupply?: string;
    };
    /** @description Event related to staking on the Vega network. */
    readonly vegaStakingEvent: {
      /**
       * Format: uint64
       * @description Block in which the transaction was added.
       */
      readonly block?: string;
      /**
       * Format: uint64
       * @description Index of the log in the transaction.
       */
      readonly index?: string;
      readonly stakeDeposited?: components['schemas']['vegaStakeDeposited'];
      readonly stakeRemoved?: components['schemas']['vegaStakeRemoved'];
      readonly totalSupply?: components['schemas']['vegaStakeTotalSupply'];
    };
    readonly vegaStakingTier: {
      /**
       * @description Required number of governance tokens ($VEGA) a referrer must have staked to
       * receive the multiplier.
       */
      readonly minimumStakedTokens?: string;
      /**
       * @description Multiplier applied to the referral reward factor when calculating referral
       * rewards due to the referrer.
       */
      readonly referralRewardMultiplier?: string;
    };
    readonly vegaStateValueProposal: {
      /** @description Event ID. */
      readonly eventId?: string;
      /** @description Key value tolerance triplets. */
      readonly kvb?: readonly components['schemas']['vegaKeyValueBundle'][];
      /** @description State variable ID. */
      readonly stateVarId?: string;
    };
    readonly vegaStateVarValue: {
      readonly matrixVal?: components['schemas']['vegaMatrixValue'];
      readonly scalarVal?: components['schemas']['vegaScalarValue'];
      readonly vectorVal?: components['schemas']['vegaVectorValue'];
    };
    /** @description Configuration required to turn a new market proposal in to a successor market proposal. */
    readonly vegaSuccessorConfiguration: {
      /** @description A decimal value between or equal to 0 and 1, specifying the fraction of the insurance pool balance that is carried over from the parent market to the successor. */
      readonly insurancePoolFraction?: string;
      /** @description ID of the market that the successor should take over from. */
      readonly parentMarketId?: string;
    };
    /** TargetStakeParameters contains parameters used in target stake calculation */
    readonly vegaTargetStakeParameters: {
      /**
       * Format: double
       * @description Specifies scaling factors used in target stake calculation.
       */
      readonly scalingFactor?: number;
      /**
       * Format: int64
       * @description Specifies length of time window expressed in seconds for target stake calculation.
       */
      readonly timeWindow?: string;
    };
    /** Update an existing asset on Vega */
    readonly vegaUpdateAsset: {
      /** @description Asset ID the update is for. */
      readonly assetId?: string;
      /** @description Changes to apply on an existing asset. */
      readonly changes?: components['schemas']['vegaAssetDetailsUpdate'];
    };
    /** Future product configuration */
    readonly vegaUpdateFutureProduct: {
      /** @description The binding between the data source spec and the settlement data. */
      readonly dataSourceSpecBinding?: components['schemas']['vegaDataSourceSpecToFutureBinding'];
      /** @description The data source spec describing the data of settlement data. */
      readonly dataSourceSpecForSettlementData?: components['schemas']['vegaDataSourceDefinition'];
      /** @description The data source spec describing the data source for trading termination. */
      readonly dataSourceSpecForTradingTermination?: components['schemas']['vegaDataSourceDefinition'];
      /** @description Human-readable name/abbreviation of the quote name. */
      readonly quoteName?: string;
    };
    /** Instrument configuration */
    readonly vegaUpdateInstrumentConfiguration: {
      /** @description Instrument code, human-readable shortcode used to describe the instrument. */
      readonly code?: string;
      /** @description Future. */
      readonly future?: components['schemas']['vegaUpdateFutureProduct'];
      /** @description Perpetual. */
      readonly perpetual?: components['schemas']['vegaUpdatePerpetualProduct'];
    };
    /** Update an existing market on Vega */
    readonly vegaUpdateMarket: {
      /** @description Updated configuration of the futures market. */
      readonly changes?: components['schemas']['vegaUpdateMarketConfiguration'];
      /** @description Market ID the update is for. */
      readonly marketId?: string;
    };
    /** Configuration to update a futures market on Vega */
    readonly vegaUpdateMarketConfiguration: {
      /** @description Updated futures market instrument configuration. */
      readonly instrument?: components['schemas']['vegaUpdateInstrumentConfiguration'];
      /** @description Linear slippage factor is used to cap the slippage component of maintenance margin - it is applied to the slippage volume. */
      readonly linearSlippageFactor?: string;
      /** @description Liquidity monitoring parameters. */
      readonly liquidityMonitoringParameters?: components['schemas']['vegaLiquidityMonitoringParameters'];
      /** Liquidity SLA parameters */
      readonly liquiditySlaParameters?: components['schemas']['vegaLiquiditySLAParameters'];
      /** @description Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected. */
      readonly logNormal?: components['schemas']['vegaLogNormalRiskModel'];
      /**
       * @description DEPRECATED: Use liquidity SLA parameters instead.
       * Percentage move up and down from the mid price which specifies the range of
       * price levels over which automated liquidity provisions will be deployed.
       */
      readonly lpPriceRange?: string;
      /** @description Optional futures market metadata, tags. */
      readonly metadata?: readonly string[];
      /** @description Price monitoring parameters. */
      readonly priceMonitoringParameters?: components['schemas']['vegaPriceMonitoringParameters'];
      /** @description Simple risk model parameters, valid only if MODEL_SIMPLE is selected. */
      readonly simple?: components['schemas']['vegaSimpleModelParams'];
    };
    readonly vegaUpdateMarketState: {
      /** Configuration for governance-initiated change of a market's state */
      readonly changes?: components['schemas']['vegaUpdateMarketStateConfiguration'];
    };
    readonly vegaUpdateMarketStateConfiguration: {
      /** ID of the market */
      readonly marketId?: string;
      /** Settlement price, relevant only for market termination for futures markets */
      readonly price?: string;
      /** Type of the market update */
      readonly updateType?: components['schemas']['vegaMarketStateUpdateType'];
    };
    /** Update network configuration on Vega */
    readonly vegaUpdateNetworkParameter: {
      /** @description The network parameter to update. */
      readonly changes?: components['schemas']['vegaNetworkParameter'];
    };
    /** Perpetual product configuration */
    readonly vegaUpdatePerpetualProduct: {
      /** @description Lower bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1]. */
      readonly clampLowerBound?: string;
      /** @description Upper bound for the clamp function used as part of the funding rate calculation, in the range [-1, 1]. */
      readonly clampUpperBound?: string;
      /** @description Binding between the data source spec and the settlement data. */
      readonly dataSourceSpecBinding?: components['schemas']['vegaDataSourceSpecToPerpetualBinding'];
      /** @description Data source spec describing the data source for settlement. */
      readonly dataSourceSpecForSettlementData?: components['schemas']['vegaDataSourceDefinition'];
      /** @description Data source spec describing the data source for settlement schedule. */
      readonly dataSourceSpecForSettlementSchedule?: components['schemas']['vegaDataSourceDefinition'];
      /** @description Continuously compounded interest rate used in funding rate calculation, in the range [-1, 1]. */
      readonly interestRate?: string;
      /** @description Controls how much the upcoming funding payment liability contributes to party's margin, in the range [0, 1]. */
      readonly marginFundingFactor?: string;
      /** @description Human-readable name/abbreviation of the quote name. */
      readonly quoteName?: string;
    };
    readonly vegaUpdateReferralProgram: {
      /** @description Configuration for change to update a referral program. */
      readonly changes?: components['schemas']['vegaReferralProgramChanges'];
    };
    /** Update an existing spot market on Vega */
    readonly vegaUpdateSpotMarket: {
      /** @description Updated configuration of the spot market. */
      readonly changes?: components['schemas']['vegaUpdateSpotMarketConfiguration'];
      /** @description Market ID the update is for. */
      readonly marketId?: string;
    };
    /** Configuration to update a spot market on Vega */
    readonly vegaUpdateSpotMarketConfiguration: {
      /** @description Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected. */
      readonly logNormal?: components['schemas']['vegaLogNormalRiskModel'];
      /** @description Optional spot market metadata, tags. */
      readonly metadata?: readonly string[];
      /** @description Price monitoring parameters. */
      readonly priceMonitoringParameters?: components['schemas']['vegaPriceMonitoringParameters'];
      /** @description Simple risk model parameters, valid only if MODEL_SIMPLE is selected. */
      readonly simple?: components['schemas']['vegaSimpleModelParams'];
      /** @description Specifies the liquidity provision SLA parameters. */
      readonly slaParams?: components['schemas']['vegaLiquiditySLAParameters'];
      /** @description Specifies parameters related to target stake calculation. */
      readonly targetStakeParameters?: components['schemas']['vegaTargetStakeParameters'];
    };
    readonly vegaUpdateVolumeDiscountProgram: {
      /** Configuration for a change to update a volume discount program */
      readonly changes?: components['schemas']['vegaVolumeDiscountProgramChanges'];
    };
    readonly vegaVectorValue: {
      readonly value?: readonly string[];
    };
    readonly vegaVolumeBenefitTier: {
      /**
       * @description Required running notional taker volume in quantum units for parties
       * to access this tier.
       */
      readonly minimumRunningNotionalTakerVolume?: string;
      /** @description Proportion of the taker fees to be discounted. */
      readonly volumeDiscountFactor?: string;
    };
    readonly vegaVolumeDiscountProgramChanges: {
      /**
       * @description Defined benefit tiers in increasing order. First element will give Tier 1,
       * second element will give Tier 2, and so on. Determines the level of
       * benefit a party can expect based on performance criteria.
       */
      readonly benefitTiers?: readonly components['schemas']['vegaVolumeBenefitTier'][];
      /**
       * Format: int64
       * @description Timestamp as Unix time in seconds, after which when the current epoch
       * ends, the program will end and benefits will be disabled.
       */
      readonly endOfProgramTimestamp?: string;
      /**
       * Format: uint64
       * @description Number of epochs over which to evaluate a referral set's running volume.
       */
      readonly windowLength?: string;
    };
    /**
     * Vote value
     * @description - VALUE_UNSPECIFIED: Default value, always invalid
     *  - VALUE_NO: Vote against the proposal
     *  - VALUE_YES: Vote in favour of the proposal
     * @default VALUE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaVoteValue: 'VALUE_UNSPECIFIED' | 'VALUE_NO' | 'VALUE_YES';
    /** Withdrawal external details */
    readonly vegaWithdrawExt: {
      /** @description ERC20 withdrawal details. */
      readonly erc20?: components['schemas']['vegaErc20WithdrawExt'];
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {
  /**
   * Info
   * @description Get information about the block explorer.
   * Response contains a semver formatted version of the data node and the commit hash, from which the block explorer was built
   */
  BlockExplorer_Info: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          readonly 'application/json': components['schemas']['v1InfoResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          readonly 'application/json': components['schemas']['googlerpcStatus'];
        };
      };
    };
  };
  /**
   * List transactions
   * @description List transactions from the Vega blockchain
   */
  BlockExplorer_ListTransactions: {
    parameters: {
      query?: {
        /**
         * @description Number of transactions to be returned from the blockchain.
         * This is deprecated, use first and last instead.
         */
        limit?: number;
        /** @description Optional cursor to paginate the request. */
        before?: string;
        /** @description Optional cursor to paginate the request. */
        after?: string;
        /** @description Transaction command types filter, for listing transactions with specified command types. */
        cmdTypes?: readonly string[];
        /** @description Transaction command types exclusion filter, for listing all the transactions except the ones with specified command types. */
        excludeCmdTypes?: readonly string[];
        /** @description Party IDs filter, can be sender or receiver. */
        parties?: readonly string[];
        /**
         * @description Number of transactions to be returned from the blockchain. Use in conjunction with the `after` cursor to paginate forwards.
         * On its own, this will return the first `first` transactions.
         */
        first?: number;
        /**
         * @description Number of transactions to be returned from the blockchain. Use in conjunction with the `before` cursor to paginate backwards.
         * On its own, this will return the last `last` transactions.
         */
        last?: number;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          readonly 'application/json': components['schemas']['v1ListTransactionsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          readonly 'application/json': components['schemas']['googlerpcStatus'];
        };
      };
    };
  };
  /**
   * Get transaction
   * @description Get a transaction from the Vega blockchain
   */
  BlockExplorer_GetTransaction: {
    parameters: {
      path: {
        /** @description Hash of the transaction */
        hash: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          readonly 'application/json': components['schemas']['v1GetTransactionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          readonly 'application/json': components['schemas']['googlerpcStatus'];
        };
      };
    };
  };
}
