/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

/** Type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = T | U extends object
  ? (Without<T, U> & U) | (Without<U, T> & T)
  : T | U;
/* eslint-disable @typescript-eslint/no-explicit-any */
type OneOf<T extends any[]> = T extends [infer Only]
  ? Only
  : T extends [infer A, infer B, ...infer Rest]
  ? OneOf<[XOR<A, B>, ...Rest]>
  : never;
/* eslint-enable @typescript-eslint/no-explicit-any */
export interface paths {
  '/info': {
    /**
     * Info
     * @description Retrieves information about the block explorer.
     * Response contains a semver formatted version of the data node and the commit hash, from which the block explorer was built,
     */
    get: operations['BlockExplorer_Info'];
  };
  '/transactions': {
    /**
     * List transactions
     * @description List transactions from the Vega blockchain
     */
    get: operations['BlockExplorer_ListTransactions'];
  };
  '/transactions/{hash}': {
    /**
     * Get transaction
     * @description Get a transaction from the Vega blockchain
     */
    get: operations['BlockExplorer_GetTransaction'];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /**
     * @description Comparator describes the type of comparison.
     *
     *  - OPERATOR_UNSPECIFIED: The default value
     *  - OPERATOR_EQUALS: Verify if the property values are strictly equal or not.
     *  - OPERATOR_GREATER_THAN: Verify if the data source data value is greater than the Condition value.
     *  - OPERATOR_GREATER_THAN_OR_EQUAL: Verify if the data source data value is greater than or equal to the Condition
     * value.
     *  - OPERATOR_LESS_THAN: Verify if the data source data value is less than the Condition value.
     *  - OPERATOR_LESS_THAN_OR_EQUAL: Verify if the data source data value is less or equal to than the Condition
     * value.
     * @default OPERATOR_UNSPECIFIED
     * @enum {string}
     */
    readonly ConditionOperator:
      | 'OPERATOR_UNSPECIFIED'
      | 'OPERATOR_EQUALS'
      | 'OPERATOR_GREATER_THAN'
      | 'OPERATOR_GREATER_THAN_OR_EQUAL'
      | 'OPERATOR_LESS_THAN'
      | 'OPERATOR_LESS_THAN_OR_EQUAL';
    /**
     * The supported Oracle sources
     * @description - ORACLE_SOURCE_UNSPECIFIED: The default value
     *  - ORACLE_SOURCE_OPEN_ORACLE: Specifies that the payload will be base64 encoded JSON conforming to the Open Oracle standard
     *  - ORACLE_SOURCE_JSON: Specifies that the payload will be base64 encoded JSON, but does not specify the shape of the data
     * @default ORACLE_SOURCE_UNSPECIFIED
     * @enum {string}
     */
    readonly OracleDataSubmissionOracleSource:
      | 'ORACLE_SOURCE_UNSPECIFIED'
      | 'ORACLE_SOURCE_OPEN_ORACLE'
      | 'ORACLE_SOURCE_JSON';
    /**
     * Time In Force for an order
     * @description - TIME_IN_FORCE_UNSPECIFIED: Default value for TimeInForce, can be valid for an amend
     *  - TIME_IN_FORCE_GTC: Good until cancelled, the order trades any amount and as much as possible
     * and remains on the book until it either trades completely or is cancelled
     *  - TIME_IN_FORCE_GTT: Good until specified time, this order type trades any amount and as much as possible
     * and remains on the book until it either trades completely, is cancelled, or expires at a set time
     * NOTE: this may in future be multiple types or have sub types for orders that provide different ways of specifying expiry
     *  - TIME_IN_FORCE_IOC: Immediate or cancel, the order trades any amount and as much as possible
     * but does not remain on the book (whether it trades or not)
     *  - TIME_IN_FORCE_FOK: Fill or kill, The order either trades completely (remainingSize == 0 after adding)
     * or not at all, does not remain on the book if it doesn't trade
     *  - TIME_IN_FORCE_GFA: Good for auction, this order is only accepted during an auction period
     *  - TIME_IN_FORCE_GFN: Good for normal, this order is only accepted during normal trading (that can be continuous trading or frequent batched auctions)
     * @default TIME_IN_FORCE_UNSPECIFIED
     * @enum {string}
     */
    readonly OrderTimeInForce:
      | 'TIME_IN_FORCE_UNSPECIFIED'
      | 'TIME_IN_FORCE_GTC'
      | 'TIME_IN_FORCE_GTT'
      | 'TIME_IN_FORCE_IOC'
      | 'TIME_IN_FORCE_FOK'
      | 'TIME_IN_FORCE_GFA'
      | 'TIME_IN_FORCE_GFN';
    /**
     * @default METHOD_UNSPECIFIED
     * @enum {string}
     */
    readonly UndelegateSubmissionMethod:
      | 'METHOD_UNSPECIFIED'
      | 'METHOD_NOW'
      | 'METHOD_AT_END_OF_EPOCH';
    readonly blockexplorerapiv1Transaction: {
      /**
       * The height of the block the transaction was found in
       * Format: uint64
       */
      readonly block?: string;
      /**
       * The results code of the transaction (0 is success)
       * Format: int64
       */
      readonly code?: number;
      /** The actual command of the transaction */
      readonly command?: components['schemas']['v1InputData'];
      /** The cursor for this transaction (in the page, used for paginated results) */
      readonly cursor?: string;
      /**
       * An optional error happening when processing / checking the transaction
       * Should be set if error code is not 0
       */
      readonly error?: string;
      /** The hash of the transaction */
      readonly hash?: string;
      /**
       * The index of the transaction in the block
       * Format: int64
       */
      readonly index?: number;
      /** Submitter's signature of transaction */
      readonly signature?: components['schemas']['v1Signature'];
      /** The submitter of the transaction (Vega public key) */
      readonly submitter?: string;
      /** The type of transaction */
      readonly type?: string;
    };
    /** A transfer initiated by a party */
    readonly commandsv1Transfer: {
      /** The amount to be taken from the source account */
      readonly amount?: string;
      /** The asset */
      readonly asset?: string;
      /**
       * The account type from which the funds of the party
       * should be taken
       */
      readonly fromAccountType?: components['schemas']['vegaAccountType'];
      readonly oneOff?: components['schemas']['v1OneOffTransfer'];
      readonly recurring?: components['schemas']['v1RecurringTransfer'];
      /** The reference to be attached to the transfer */
      readonly reference?: string;
      /** The public key of the destination account */
      readonly to?: string;
      /** The type of the destination account */
      readonly toAccountType?: components['schemas']['vegaAccountType'];
    };
    readonly googlerpcStatus: {
      /** Format: int32 */
      readonly code?: number;
      readonly details?: readonly components['schemas']['protobufAny'][];
      readonly message?: string;
    };
    readonly protobufAny: {
      readonly '@type'?: string;
      [key: string]: unknown | undefined;
    };
    /** Used announce a node as a new pending validator */
    readonly v1AnnounceNode: {
      /** AvatarURL of the validator */
      readonly avatarUrl?: string;
      /** Public key for the blockchain, required field */
      readonly chainPubKey?: string;
      /** Country code (ISO 3166-1 alpha-2) for the location of the node */
      readonly country?: string;
      /** Ethereum public key, required field */
      readonly ethereumAddress?: string;
      /** Signature from the validator made using the ethereum wallet */
      readonly ethereumSignature?: components['schemas']['v1Signature'];
      /**
       * The epoch from which the validator is expected
       * to be ready to validate blocks
       * Format: uint64
       */
      readonly fromEpoch?: string;
      /** ID of the validator, (public master key) */
      readonly id?: string;
      /** URL with more info on the node */
      readonly infoUrl?: string;
      /** Name of the validator */
      readonly name?: string;
      /** Ethereum public key to use as a submitter to allow automatic signature generation */
      readonly submitterAddress?: string;
      /** Vega public key, required field */
      readonly vegaPubKey?: string;
      /**
       * Vega public key derivation index
       * Format: int64
       */
      readonly vegaPubKeyIndex?: number;
      /** Signature from the validator made using the Vega wallet */
      readonly vegaSignature?: components['schemas']['v1Signature'];
    };
    /**
     * A batch of order instructions.
     * This command accepts only the following batches of commands
     * and will be processed in the following order:
     * - OrderCancellation
     * - OrderAmendment
     * - OrderSubmission
     * The total amount of commands in the batch across all three lists of
     * instructions is restricted by the following network parameter:
     * "spam.protection.max.batchSize"
     */
    readonly v1BatchMarketInstructions: {
      /** A list of order amendments to be processed sequentially */
      readonly amendments?: readonly components['schemas']['v1OrderAmendment'][];
      /** A list of order cancellations to be processed sequentially */
      readonly cancellations?: readonly components['schemas']['v1OrderCancellation'][];
      /** A list of order submissions to be processed sequentially */
      readonly submissions?: readonly components['schemas']['v1OrderSubmission'][];
    };
    /** A request for cancelling a recurring transfer */
    readonly v1CancelTransfer: {
      /** The ID of the transfer to cancel */
      readonly transferId?: string;
    };
    /** An event forwarded to the Vega network to provide information on events happening on other networks */
    readonly v1ChainEvent: {
      /** Built-in asset event */
      readonly builtin?: components['schemas']['vegaBuiltinAssetEvent'];
      /** Ethereum ERC20 event */
      readonly erc20?: components['schemas']['vegaERC20Event'];
      /** Ethereum ERC20 multisig event */
      readonly erc20Multisig?: components['schemas']['vegaERC20MultiSigEvent'];
      /**
       * Arbitrary one-time integer used to prevent replay attacks
       * Format: uint64
       */
      readonly nonce?: string;
      /** Ethereum Staking event */
      readonly stakingEvent?: components['schemas']['vegaStakingEvent'];
      /** The identifier of the transaction in which the events happened, usually a hash */
      readonly txId?: string;
    };
    /** Condition describes the condition that must be validated by the network */
    readonly v1Condition: {
      /** @description comparator is the type of comparison to make on the value. */
      readonly operator?: components['schemas']['ConditionOperator'];
      /** @description value is used by the comparator. */
      readonly value?: string;
    };
    /** A command to submit an instruction to delegate some stake to a node */
    readonly v1DelegateSubmission: {
      /** The amount of stake to delegate */
      readonly amount?: string;
      /** The ID for the node to delegate to */
      readonly nodeId?: string;
    };
    readonly v1ETHAddress: {
      readonly address?: string;
    };
    /** A transaction to allow validator to rotate their ethereum keys */
    readonly v1EthereumKeyRotateSubmission: {
      /** Currently used public address */
      readonly currentAddress?: string;
      /** Signature that can be verified using the new ethereum address */
      readonly ethereumSignature?: components['schemas']['v1Signature'];
      /** The new adress to rotate to */
      readonly newAddress?: string;
      /** Ethereum public key to use as a submitter to allow automatic signature generation */
      readonly submitterAddress?: string;
      /**
       * Target block at which the key rotation will take effect on
       * Format: uint64
       */
      readonly targetBlock?: string;
    };
    /**
     * @description Filter describes the conditions under which a data source data is considered of
     * interest or not.
     */
    readonly v1Filter: {
      /**
       * @description conditions are the conditions that should be matched by the data to be
       * considered of interest.
       */
      readonly conditions?: readonly components['schemas']['v1Condition'][];
      /** @description key is the data source data property key targeted by the filter. */
      readonly key?: components['schemas']['v1PropertyKey'];
    };
    readonly v1GetTransactionResponse: {
      /** The transaction corresponding to the hash */
      readonly transaction?: components['schemas']['blockexplorerapiv1Transaction'];
    };
    readonly v1InfoResponse: {
      /** The commit hash from which the data-node was built */
      readonly commitHash?: string;
      /** A semver formatted version of the data node */
      readonly version?: string;
    };
    readonly v1InputData: {
      readonly announceNode?: components['schemas']['v1AnnounceNode'];
      readonly batchMarketInstructions?: components['schemas']['v1BatchMarketInstructions'];
      /**
       * Format: uint64
       * @description The block height at which the transaction was made.
       * This should be the current block height. The transaction will be valid
       * from the block and up to the `tolerance` block height.
       * Example: If the network has a tolerance of 150 blocks and `block_height`
       * is set to `200`, then the transaction will be valid until block `350`.
       * Note that a `block_height` that is ahead of the real block height will be
       * rejected. The tolerance can be queried from the chain's network parameters.
       * `block_height` prevents replay attacks in conjunction with `nonce` (see above).
       */
      readonly blockHeight?: string;
      readonly cancelTransfer?: components['schemas']['v1CancelTransfer'];
      readonly chainEvent?: components['schemas']['v1ChainEvent'];
      readonly delegateSubmission?: components['schemas']['v1DelegateSubmission'];
      readonly ethereumKeyRotateSubmission?: components['schemas']['v1EthereumKeyRotateSubmission'];
      readonly issueSignatures?: components['schemas']['v1IssueSignatures'];
      readonly keyRotateSubmission?: components['schemas']['v1KeyRotateSubmission'];
      readonly liquidityProvisionAmendment?: components['schemas']['v1LiquidityProvisionAmendment'];
      readonly liquidityProvisionCancellation?: components['schemas']['v1LiquidityProvisionCancellation'];
      readonly liquidityProvisionSubmission?: components['schemas']['v1LiquidityProvisionSubmission'];
      readonly nodeSignature?: components['schemas']['v1NodeSignature'];
      /** Validator commands */
      readonly nodeVote?: components['schemas']['v1NodeVote'];
      /**
       * Format: uint64
       * @description A number to provide uniqueness to prevent accidental replays and,
       * in combination with `block_height`, deliberate attacks.
       * A nonce provides uniqueness for otherwise identical transactions,
       * ensuring that the transaction hash uniquely identifies a specific transaction.
       * Granted all other fields are equal, the nonce can either be a counter
       * or generated at random to submit multiple transactions within the same
       * block (see below), without being identified as replays.
       * Please note that Protocol Buffers do not have a canonical, unique encoding
       * and therefore different libraries or binaries may encode the same message
       * slightly differently, causing a different hash.
       */
      readonly nonce?: string;
      /** Oracles */
      readonly oracleDataSubmission?: components['schemas']['v1OracleDataSubmission'];
      readonly orderAmendment?: components['schemas']['v1OrderAmendment'];
      readonly orderCancellation?: components['schemas']['v1OrderCancellation'];
      /** User commands */
      readonly orderSubmission?: components['schemas']['v1OrderSubmission'];
      readonly proposalSubmission?: components['schemas']['v1ProposalSubmission'];
      readonly protocolUpgradeProposal?: components['schemas']['v1ProtocolUpgradeProposal'];
      readonly stateVariableProposal?: components['schemas']['v1StateVariableProposal'];
      readonly transfer?: components['schemas']['commandsv1Transfer'];
      readonly undelegateSubmission?: components['schemas']['v1UndelegateSubmission'];
      readonly validatorHeartbeat?: components['schemas']['v1ValidatorHeartbeat'];
      readonly voteSubmission?: components['schemas']['v1VoteSubmission'];
      readonly withdrawSubmission?: components['schemas']['v1WithdrawSubmission'];
    };
    readonly v1IssueSignatures: {
      /** The kind of signatures to generate, namely for whether a signer is being added or removed */
      readonly kind?: components['schemas']['v1NodeSignatureKind'];
      /** The ethereum address which will submit the signatures to the smart-contract */
      readonly submitter?: string;
      /** The ID of the node that will be signed in or out of the smartcontract */
      readonly validatorNodeId?: string;
    };
    /** A transaction to allow validator to rotate their Vega keys */
    readonly v1KeyRotateSubmission: {
      /** Hash of currently used public key */
      readonly currentPubKeyHash?: string;
      /** The new public key to rotate to */
      readonly newPubKey?: string;
      /**
       * New Vega public key derivation index
       * Format: int64
       */
      readonly newPubKeyIndex?: number;
      /**
       * Target block at which the key rotation will take effect on
       * Format: uint64
       */
      readonly targetBlock?: string;
    };
    /** Amend a liquidity provision request */
    readonly v1LiquidityProvisionAmendment: {
      readonly buys?: readonly components['schemas']['vegaLiquidityOrder'][];
      /** From here at least one of the following is required to consider the command valid */
      readonly commitmentAmount?: string;
      readonly fee?: string;
      readonly marketId?: string;
      readonly reference?: string;
      readonly sells?: readonly components['schemas']['vegaLiquidityOrder'][];
    };
    /** Cancel a liquidity provision request */
    readonly v1LiquidityProvisionCancellation: {
      readonly marketId?: string;
    };
    /** A liquidity provision submitted for a given market */
    readonly v1LiquidityProvisionSubmission: {
      /** A set of liquidity buy orders to meet the liquidity provision obligation */
      readonly buys?: readonly components['schemas']['vegaLiquidityOrder'][];
      /** Specified as a unitless number that represents the amount of settlement asset of the market */
      readonly commitmentAmount?: string;
      /** Nominated liquidity fee factor, which is an input to the calculation of taker fees on the market, as per setting fees and rewarding liquidity providers */
      readonly fee?: string;
      /** Market identifier for the order, required field */
      readonly marketId?: string;
      /** A reference to be added to every order created out of this liquidityProvisionSubmission */
      readonly reference?: string;
      /** A set of liquidity sell orders to meet the liquidity provision obligation */
      readonly sells?: readonly components['schemas']['vegaLiquidityOrder'][];
    };
    readonly v1ListTransactionsResponse: {
      /** The transaction corresponding to the specific request and filters */
      readonly transactions?: readonly components['schemas']['blockexplorerapiv1Transaction'][];
    };
    /** Represents a signature from a validator, to be used by a foreign chain in order to recognise a decision taken by the Vega network */
    readonly v1NodeSignature: {
      /** The identifier of the resource being signed */
      readonly id?: string;
      /** The kind of resource being signed */
      readonly kind?: components['schemas']['v1NodeSignatureKind'];
      /**
       * The signature
       * Format: byte
       */
      readonly sig?: string;
    };
    /**
     * The kind of signature created by a node, for example, allow-listing a new asset, withdrawal etc
     * @description - NODE_SIGNATURE_KIND_UNSPECIFIED: Represents an unspecified or missing value from the input
     *  - NODE_SIGNATURE_KIND_ASSET_NEW: Represents a signature for a new asset allow-listing
     *  - NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL: Represents a signature for an asset withdrawal
     *  - NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED: Represents a signature for a new signer added to the erc20 multisig contract
     *  - NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED: Represents a signature for a signer removed from the erc20 multisig contract
     *  - NODE_SIGNATURE_KIND_ASSET_UPDATE: Represents a signature for an asset update allow-listing
     * @default NODE_SIGNATURE_KIND_UNSPECIFIED
     * @enum {string}
     */
    readonly v1NodeSignatureKind:
      | 'NODE_SIGNATURE_KIND_UNSPECIFIED'
      | 'NODE_SIGNATURE_KIND_ASSET_NEW'
      | 'NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL'
      | 'NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_ADDED'
      | 'NODE_SIGNATURE_KIND_ERC20_MULTISIG_SIGNER_REMOVED'
      | 'NODE_SIGNATURE_KIND_ASSET_UPDATE';
    /**
     * Used when a node votes for validating that a given resource exists or is valid,
     * for example, an ERC20 deposit is valid and exists on ethereum
     */
    readonly v1NodeVote: {
      /** Reference, required field */
      readonly reference?: string;
      /** type of NodeVote, also required */
      readonly type?: components['schemas']['v1NodeVoteType'];
    };
    /**
     * - TYPE_UNSPECIFIED: Represents an unspecified or missing value from the input
     *  - TYPE_STAKE_DEPOSITED: A node vote a new stake deposit
     *  - TYPE_STAKE_REMOVED: A node vote for a new stake removed event
     *  - TYPE_FUNDS_DEPOSITED: A node vote for new collateral deposited
     *  - TYPE_SIGNER_ADDED: A node vote for a new signer added to the erc20 bridge
     *  - TYPE_SIGNER_REMOVED: A node vote for a signer removed from the erc20 bridge
     *  - TYPE_BRIDGE_STOPPED: A node vote for a bridge stopped event
     *  - TYPE_BRIDGE_RESUMED: A node vote for a bridge resumed event
     *  - TYPE_ASSET_LISTED: A node vote for a newly listed asset
     *  - TYPE_LIMITS_UPDATED: A node vote for an asset limits update
     *  - TYPE_STAKE_TOTAL_SUPPLY: A node vote to share the total supply of the staking token
     *  - TYPE_SIGNER_THRESHOLD_SET: A node vote to update the threshold of the signer set for the multisig contract
     *  - TYPE_GOVERNANCE_VALIDATE_ASSET: A node vote to validate a new assert governance proposal
     * @default TYPE_UNSPECIFIED
     * @enum {string}
     */
    readonly v1NodeVoteType:
      | 'TYPE_UNSPECIFIED'
      | 'TYPE_STAKE_DEPOSITED'
      | 'TYPE_STAKE_REMOVED'
      | 'TYPE_FUNDS_DEPOSITED'
      | 'TYPE_SIGNER_ADDED'
      | 'TYPE_SIGNER_REMOVED'
      | 'TYPE_BRIDGE_STOPPED'
      | 'TYPE_BRIDGE_RESUMED'
      | 'TYPE_ASSET_LISTED'
      | 'TYPE_LIMITS_UPDATED'
      | 'TYPE_STAKE_TOTAL_SUPPLY'
      | 'TYPE_SIGNER_THRESHOLD_SET'
      | 'TYPE_GOVERNANCE_VALIDATE_ASSET';
    /** Specific details for a one off transfer */
    readonly v1OneOffTransfer: {
      /**
       * A unix timestamp in second. Time at which the
       * transfer should be delivered in the to account
       * Format: int64
       */
      readonly deliverOn?: string;
    };
    /** Command to submit new Oracle data from third party providers */
    readonly v1OracleDataSubmission: {
      /**
       * The data provided by the data source
       * In the case of Open Oracle - it will be the entire object - it will contain messages, signatures and price data
       * Format: byte
       */
      readonly payload?: string;
      /**
       * @description The source from which the data is coming from. Must be base64 encoded.
       * Oracle data a type of external data source data.
       */
      readonly source?: components['schemas']['OracleDataSubmissionOracleSource'];
    };
    /** An order amendment is a request to amend or update an existing order on Vega */
    readonly v1OrderAmendment: {
      /**
       * Amend the expiry time for the order, if the Timestamp value is set, otherwise expiry time will remain unchanged
       * - See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`
       * Format: int64
       */
      readonly expiresAt?: string;
      /** Market identifier, this is required to find the order and will not be updated */
      readonly marketId?: string;
      /** Order identifier, this is required to find the order and will not be updated, required field */
      readonly orderId?: string;
      /** Amend the pegged order offset for the order */
      readonly peggedOffset?: string;
      /**
       * Amend the pegged order reference for the order
       * - See [`PeggedReference`](#vega.PeggedReference)
       */
      readonly peggedReference?: components['schemas']['vegaPeggedReference'];
      /** Amend the price for the order, if the Price value is set, otherwise price will remain unchanged - See [`Price`](#vega.Price) */
      readonly price?: string;
      /**
       * Amend the size for the order by the delta specified:
       * - To reduce the size from the current value set a negative integer value
       * - To increase the size from the current value, set a positive integer value
       * - To leave the size unchanged set a value of zero
       * Format: int64
       */
      readonly sizeDelta?: string;
      /**
       * Amend the time in force for the order, set to TIME_IN_FORCE_UNSPECIFIED to remain unchanged
       * - See [`TimeInForce`](#api.VegaTimeResponse).`timestamp`
       */
      readonly timeInForce?: components['schemas']['OrderTimeInForce'];
    };
    /** An order cancellation is a request to cancel an existing order on Vega */
    readonly v1OrderCancellation: {
      /** Market identifier for the order, required field */
      readonly marketId?: string;
      /** Unique identifier for the order (set by the system after consensus), required field */
      readonly orderId?: string;
    };
    /** An order submission is a request to submit or create a new order on Vega */
    readonly v1OrderSubmission: {
      /**
       * Timestamp for when the order will expire, in nanoseconds since the epoch,
       * required field only for `Order.TimeInForce`.TIME_IN_FORCE_GTT`
       * - See `VegaTimeResponse`.`timestamp`
       * Format: int64
       */
      readonly expiresAt?: string;
      /** Market identifier for the order, required field */
      readonly marketId?: string;
      /**
       * Used to specify the details for a pegged order
       * - See `PeggedOrder`
       */
      readonly peggedOrder?: components['schemas']['vegaPeggedOrder'];
      /**
       * Price for the order, the price is an integer, for example `123456` is a correctly
       * formatted price of `1.23456` assuming market configured to 5 decimal places,
       * , required field for limit orders, however it is not required for market orders
       */
      readonly price?: string;
      /**
       * Reference given for the order, this is typically used to retrieve an order submitted through consensus, currently
       * set internally by the node to return a unique reference identifier for the order submission
       */
      readonly reference?: string;
      /**
       * Side for the order, e.g. SIDE_BUY or SIDE_SELL, required field
       * - See `Side`
       */
      readonly side?: components['schemas']['vegaSide'];
      /**
       * Size for the order, for example, in a futures market the size equals the number of units, cannot be negative
       * Format: uint64
       */
      readonly size?: string;
      /**
       * Time in force indicates how long an order will remain active before it is executed or expires, required field
       * - See `Order.TimeInForce`
       */
      readonly timeInForce?: components['schemas']['OrderTimeInForce'];
      /** Type for the order, required field - See `Order.Type` */
      readonly type?: components['schemas']['vegaOrderType'];
    };
    /** @description PropertyKey describes the property key contained in an data source data. */
    readonly v1PropertyKey: {
      /** @description name is the name of the property. */
      readonly name?: string;
      /**
       * An optional decimal place to be be applied on the provided value
       * valid only for PropertyType of type DECIMAL and INTEGER
       * Format: uint64
       */
      readonly numberDecimalPlaces?: string;
      /** @description type is the type of the property. */
      readonly type?: components['schemas']['v1PropertyKeyType'];
    };
    /**
     * @description Type describes the type of properties that are supported by the data source
     * engine.
     *
     *  - TYPE_UNSPECIFIED: The default value.
     *  - TYPE_EMPTY: Any type.
     *  - TYPE_INTEGER: Integer type.
     *  - TYPE_STRING: String type.
     *  - TYPE_BOOLEAN: Boolean type.
     *  - TYPE_DECIMAL: Any floating point decimal type.
     *  - TYPE_TIMESTAMP: Timestamp date type.
     * @default TYPE_UNSPECIFIED
     * @enum {string}
     */
    readonly v1PropertyKeyType:
      | 'TYPE_UNSPECIFIED'
      | 'TYPE_EMPTY'
      | 'TYPE_INTEGER'
      | 'TYPE_STRING'
      | 'TYPE_BOOLEAN'
      | 'TYPE_DECIMAL'
      | 'TYPE_TIMESTAMP';
    /**
     * A command to submit a new proposal for the
     * Vega network governance
     */
    readonly v1ProposalSubmission: {
      /** @description The rationale behind a proposal. */
      readonly rationale?: components['schemas']['vegaProposalRationale'];
      /** Proposal reference */
      readonly reference?: string;
      /** Proposal configuration and the actual change that is meant to be executed when proposal is enacted */
      readonly terms?: components['schemas']['vegaProposalTerms'];
    };
    readonly v1ProtocolUpgradeProposal: {
      /**
       * The block height at which to perform the upgrade
       * Format: uint64
       */
      readonly upgradeBlockHeight?: string;
      /** the release tag for the Vega binary */
      readonly vegaReleaseTag?: string;
    };
    /**
     * @description PubKey is the public key that signed this data.
     * Different public keys coming from different sources will be further separated.
     */
    readonly v1PubKey: {
      readonly key?: string;
    };
    /** Specific details for a recurring transfer */
    readonly v1RecurringTransfer: {
      /** optional parameter defining how a transfer is dispatched */
      readonly dispatchStrategy?: components['schemas']['vegaDispatchStrategy'];
      /**
       * The last epoch at which this transfer shall be paid
       * Format: uint64
       */
      readonly endEpoch?: string;
      /** factor needs to be > 0 */
      readonly factor?: string;
      /**
       * The first epoch from which this transfer shall be paid
       * Format: uint64
       */
      readonly startEpoch?: string;
    };
    /**
     * @description A signature to authenticate a transaction and to be verified by the Vega
     * network.
     */
    readonly v1Signature: {
      /** @description The algorithm used to create the signature. */
      readonly algo?: string;
      /** @description The bytes of the signature (hex-encoded). */
      readonly value?: string;
      /**
       * Format: int64
       * @description The version of the signature used to create the signature.
       */
      readonly version?: number;
    };
    readonly v1Signer: {
      /** in case of an open oracle - Ethereum address will be submitted */
      readonly ethAddress?: components['schemas']['v1ETHAddress'];
      /**
       * @description pubKeys is the list of authorized public keys that signed the data for this
       * source. All the public keys in the data should be contained in these
       * public keys.
       */
      readonly pubKey?: components['schemas']['v1PubKey'];
    };
    readonly v1StateVariableProposal: {
      /** The state value proposal details */
      readonly proposal?: components['schemas']['vegaStateValueProposal'];
    };
    readonly v1UndelegateSubmission: {
      /** optional, if not specified = ALL */
      readonly amount?: string;
      readonly method?: components['schemas']['UndelegateSubmissionMethod'];
      readonly nodeId?: string;
    };
    /**
     * A message from a validator signalling they are still online and validating blocks
     * or ready to validate blocks when they are still a pending validator
     */
    readonly v1ValidatorHeartbeat: {
      /** Signature from the validator made using the ethereum wallet */
      readonly ethereumSignature?: components['schemas']['v1Signature'];
      /** the id of the node emitting the heartbeat */
      readonly nodeId?: string;
      /** Signature from the validator made using the vega wallet */
      readonly vegaSignature?: components['schemas']['v1Signature'];
    };
    /**
     * @description A command to submit a new vote for a governance
     * proposal.
     */
    readonly v1VoteSubmission: {
      /** @description The ID of the proposal to vote for. */
      readonly proposalId?: string;
      /** The actual value of the vote */
      readonly value?: components['schemas']['vegaVoteValue'];
    };
    /** Represents the submission request to withdraw funds for a party on Vega */
    readonly v1WithdrawSubmission: {
      /** The amount to be withdrawn */
      readonly amount?: string;
      /** The asset to be withdrawn */
      readonly asset?: string;
      /** Foreign chain specifics */
      readonly ext?: components['schemas']['vegaWithdrawExt'];
    };
    /**
     * Various collateral/account types as used by Vega
     * @description - ACCOUNT_TYPE_UNSPECIFIED: Default value
     *  - ACCOUNT_TYPE_INSURANCE: Insurance pool accounts contain insurance pool funds for a market
     *  - ACCOUNT_TYPE_SETTLEMENT: Settlement accounts exist only during settlement or mark-to-market
     *  - ACCOUNT_TYPE_MARGIN: Margin accounts contain funds set aside for the margin needed to support a party's open positions.
     * Each party will have a margin account for each market they have traded in.
     * The required initial margin is allocated to each market from your general account.
     * Collateral in the margin account can't be withdrawn or used as margin on another market until
     * it is released back to the general account.
     * The Vega protocol uses an internal accounting system to segregate funds held as
     * margin from other funds to ensure they are never lost or 'double spent'
     *
     * Margin account funds will vary as margin requirements on positions change
     *  - ACCOUNT_TYPE_GENERAL: General accounts contain the collateral for a party that is not otherwise allocated. A party will
     * have multiple general accounts, one for each asset they want
     * to trade with
     *
     * General accounts are where funds are initially deposited or withdrawn from,
     * it is also the account where funds are taken to fulfil fees and initial margin requirements
     *  - ACCOUNT_TYPE_FEES_INFRASTRUCTURE: Infrastructure accounts contain fees earned by providing infrastructure on Vega
     *  - ACCOUNT_TYPE_FEES_LIQUIDITY: Liquidity accounts contain fees earned by providing liquidity on Vega markets
     *  - ACCOUNT_TYPE_FEES_MAKER: This account is created to hold fees earned by placing orders that sit on the book
     * and are then matched with an incoming order to create a trade - These fees reward parties
     * who provide the best priced liquidity that actually allows trading to take place
     *  - ACCOUNT_TYPE_BOND: This account is created to maintain liquidity providers funds commitments
     *  - ACCOUNT_TYPE_EXTERNAL: External account represents an external source (deposit/withdrawal)
     *  - ACCOUNT_TYPE_GLOBAL_INSURANCE: Global insurance account for the asset
     *  - ACCOUNT_TYPE_GLOBAL_REWARD: Global reward account for the asset
     *  - ACCOUNT_TYPE_PENDING_TRANSFERS: Per asset account used to store pending transfers (if any)
     *  - ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES: Per asset reward account for fees paid to makers
     *  - ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES: Per asset reward account for fees received by makers
     *  - ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES: Per asset reward account for fees received by liquidity providers
     *  - ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS: Per asset reward account for market proposers when the market goes above some trading threshold
     * @default ACCOUNT_TYPE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaAccountType:
      | 'ACCOUNT_TYPE_UNSPECIFIED'
      | 'ACCOUNT_TYPE_INSURANCE'
      | 'ACCOUNT_TYPE_SETTLEMENT'
      | 'ACCOUNT_TYPE_MARGIN'
      | 'ACCOUNT_TYPE_GENERAL'
      | 'ACCOUNT_TYPE_FEES_INFRASTRUCTURE'
      | 'ACCOUNT_TYPE_FEES_LIQUIDITY'
      | 'ACCOUNT_TYPE_FEES_MAKER'
      | 'ACCOUNT_TYPE_BOND'
      | 'ACCOUNT_TYPE_EXTERNAL'
      | 'ACCOUNT_TYPE_GLOBAL_INSURANCE'
      | 'ACCOUNT_TYPE_GLOBAL_REWARD'
      | 'ACCOUNT_TYPE_PENDING_TRANSFERS'
      | 'ACCOUNT_TYPE_REWARD_MAKER_PAID_FEES'
      | 'ACCOUNT_TYPE_REWARD_MAKER_RECEIVED_FEES'
      | 'ACCOUNT_TYPE_REWARD_LP_RECEIVED_FEES'
      | 'ACCOUNT_TYPE_REWARD_MARKET_PROPOSERS';
    /** The Vega representation of an external asset */
    readonly vegaAssetDetails: {
      /** A built-in asset */
      readonly builtinAsset?: components['schemas']['vegaBuiltinAsset'];
      /**
       * Number of decimal / precision handled by this asset
       * Format: uint64
       */
      readonly decimals?: string;
      /** An Ethereum ERC20 asset */
      readonly erc20?: components['schemas']['vegaERC20'];
      /** Name of the asset (e.g: Great British Pound) */
      readonly name?: string;
      /** The minimum economically meaningful amount in the asset */
      readonly quantum?: string;
      /** Symbol of the asset (e.g: GBP) */
      readonly symbol?: string;
    };
    /** @description The changes to apply on an existing asset. */
    readonly vegaAssetDetailsUpdate: {
      /** An Ethereum ERC20 asset */
      readonly erc20?: components['schemas']['vegaERC20Update'];
      /** The minimum economically meaningful amount in the asset */
      readonly quantum?: string;
    };
    /** A Vega internal asset */
    readonly vegaBuiltinAsset: {
      /** Maximum amount that can be requested by a party through the built-in asset faucet at a time */
      readonly maxFaucetAmountMint?: string;
    };
    /** A deposit for a Vega built-in asset */
    readonly vegaBuiltinAssetDeposit: {
      /** The amount to be deposited */
      readonly amount?: string;
      /** A Vega party identifier (pub-key) */
      readonly partyId?: string;
      /** A Vega network internal asset identifier */
      readonly vegaAssetId?: string;
    };
    /** An event related to a Vega built-in asset */
    readonly vegaBuiltinAssetEvent: {
      /** Built-in asset deposit */
      readonly deposit?: components['schemas']['vegaBuiltinAssetDeposit'];
      /** Built-in asset withdrawal */
      readonly withdrawal?: components['schemas']['vegaBuiltinAssetWithdrawal'];
    };
    /** A withdrawal for a Vega built-in asset */
    readonly vegaBuiltinAssetWithdrawal: {
      /** The amount to be withdrawn */
      readonly amount?: string;
      /** A Vega network party identifier (pub-key) */
      readonly partyId?: string;
      /** A Vega network internal asset identifier */
      readonly vegaAssetId?: string;
    };
    /**
     * @description DataSourceDefinition represents the top level object that deals with data sources.
     * DataSourceDefinition can be external or internal, with whatever number of data sources are defined
     * for each type in the child objects below.
     */
    readonly vegaDataSourceDefinition: {
      readonly external?: components['schemas']['vegaDataSourceDefinitionExternal'];
      readonly internal?: components['schemas']['vegaDataSourceDefinitionInternal'];
    };
    /**
     * @description DataSourceDefinitionExternal is the top level object used for all external data sources.
     * It contains one of any of the defined `SourceType` variants.
     */
    readonly vegaDataSourceDefinitionExternal: {
      readonly oracle?: components['schemas']['vegaDataSourceSpecConfiguration'];
    };
    /**
     * @description DataSourceDefinitionInternal is the top level object used for all internal data sources.
     * It contains one of any of the defined `SourceType` variants.
     */
    readonly vegaDataSourceDefinitionInternal: {
      readonly time?: components['schemas']['vegaDataSourceSpecConfigurationTime'];
    };
    /**
     * @description All types of external data sources use the same configuration set for meeting requirements
     * in order for the data to be useful for Vega - valid signatures and matching filters.
     */
    readonly vegaDataSourceSpecConfiguration: {
      /**
       * @description filters describes which source data are considered of interest or not for
       * the product (or the risk model).
       */
      readonly filters?: readonly components['schemas']['v1Filter'][];
      /**
       * @description signers is the list of authorized signatures that signed the data for this
       * source. All the signatures in the data source data should be contained in this
       * external source. All the signatures in the data should be contained in this list.
       */
      readonly signers?: readonly components['schemas']['v1Signer'][];
    };
    /** @description DataSourceSpecConfigurationTime is the internal data source used for emitting timestamps. */
    readonly vegaDataSourceSpecConfigurationTime: {
      /** @description Conditions that the timestamps should meet in order to be considered. */
      readonly conditions?: readonly components['schemas']['v1Condition'][];
    };
    /**
     * DataSourceSpecToFutureBinding describes which property of the data source data is to be
     * used as settlement data and which to use as the trading terminated trigger
     */
    readonly vegaDataSourceSpecToFutureBinding: {
      /**
       * @description settlement_data_property holds the name of the property in the source data
       * that should be used as settlement data.
       * If it is set to "prices.BTC.value", then the Future will use the value of
       * this property as settlement data.
       */
      readonly settlementDataProperty?: string;
      /** the name of the property in the data source data that signals termination of trading */
      readonly tradingTerminationProperty?: string;
    };
    /**
     * - DISPATCH_METRIC_MAKER_FEES_PAID: Dispatch metric that is using the total maker fees paid in the market
     *  - DISPATCH_METRIC_MAKER_FEES_RECEIVED: Dispatch metric that is using the total maker fees received in the market
     *  - DISPATCH_METRIC_LP_FEES_RECEIVED: Dispatch metric that is using the total LP fees received in the market
     *  - DISPATCH_METRIC_MARKET_VALUE: Dispatch metric that is using total value of the market if above the required threshold and not paid given proposer bonus yet
     * @default DISPATCH_METRIC_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaDispatchMetric:
      | 'DISPATCH_METRIC_UNSPECIFIED'
      | 'DISPATCH_METRIC_MAKER_FEES_PAID'
      | 'DISPATCH_METRIC_MAKER_FEES_RECEIVED'
      | 'DISPATCH_METRIC_LP_FEES_RECEIVED'
      | 'DISPATCH_METRIC_MARKET_VALUE';
    readonly vegaDispatchStrategy: {
      /** The asset to use for metric */
      readonly assetForMetric?: string;
      /** Optional markets in scope */
      readonly markets?: readonly string[];
      /** The metric to apply */
      readonly metric?: components['schemas']['vegaDispatchMetric'];
    };
    /** An ERC20 token based asset, living on the ethereum network */
    readonly vegaERC20: {
      /** The address of the contract for the token, on the ethereum network */
      readonly contractAddress?: string;
      /**
       * The lifetime limits deposit per address
       * note: this is a temporary measure that can be changed by governance
       */
      readonly lifetimeLimit?: string;
      /**
       * The maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.
       * There’s no limit on the size of a withdrawal
       * note: this is a temporary measure that can be changed by governance
       */
      readonly withdrawThreshold?: string;
    };
    /** An asset deny-listing for an ERC20 token */
    readonly vegaERC20AssetDelist: {
      /** The Vega network internal identifier of the asset */
      readonly vegaAssetId?: string;
    };
    readonly vegaERC20AssetLimitsUpdated: {
      /** The updated lifetime limits */
      readonly lifetimeLimits?: string;
      /** The Ethereum wallet that initiated the deposit */
      readonly sourceEthereumAddress?: string;
      /** The Vega network internal identifier of the asset */
      readonly vegaAssetId?: string;
      /** The updated withdraw threshold */
      readonly withdrawThreshold?: string;
    };
    /** An asset allow-listing for an ERC20 token */
    readonly vegaERC20AssetList: {
      /** The ethereum address of the asset */
      readonly assetSource?: string;
      /** The Vega network internal identifier of the asset */
      readonly vegaAssetId?: string;
    };
    /** An asset deposit for an ERC20 token */
    readonly vegaERC20Deposit: {
      /** The amount to be deposited */
      readonly amount?: string;
      /** The Ethereum wallet that initiated the deposit */
      readonly sourceEthereumAddress?: string;
      /** The Vega party identifier (pub-key) which is the target of the deposit */
      readonly targetPartyId?: string;
      /** The vega network internal identifier of the asset */
      readonly vegaAssetId?: string;
    };
    /** An event related to an ERC20 token */
    readonly vegaERC20Event: {
      /** De-list an ERC20 asset */
      readonly assetDelist?: components['schemas']['vegaERC20AssetDelist'];
      /** Update an ERC20 asset */
      readonly assetLimitsUpdated?: components['schemas']['vegaERC20AssetLimitsUpdated'];
      /** List an ERC20 asset */
      readonly assetList?: components['schemas']['vegaERC20AssetList'];
      /**
       * The block in which the transaction was added
       * Format: uint64
       */
      readonly block?: string;
      /** Bridge operations has been resumed */
      readonly bridgeResumed?: boolean;
      /** Bridge operations has been stopped */
      readonly bridgeStopped?: boolean;
      /** Deposit ERC20 asset */
      readonly deposit?: components['schemas']['vegaERC20Deposit'];
      /**
       * Index of the log in the transaction
       * Format: uint64
       */
      readonly index?: string;
      /** Withdraw ERC20 asset */
      readonly withdrawal?: components['schemas']['vegaERC20Withdrawal'];
    };
    /** An event related to the ERC20 MultiSig */
    readonly vegaERC20MultiSigEvent: {
      /**
       * The block in which the transaction was added
       * Format: uint64
       */
      readonly block?: string;
      /**
       * Index of the log in the transaction
       * Format: uint64
       */
      readonly index?: string;
      /** Add a signer to the erc20 bridge */
      readonly signerAdded?: components['schemas']['vegaERC20SignerAdded'];
      /** Remove a signer from the erc20 bridge */
      readonly signerRemoved?: components['schemas']['vegaERC20SignerRemoved'];
      /** Threshold set */
      readonly thresholdSet?: components['schemas']['vegaERC20ThresholdSet'];
    };
    /** A new signer added to the ERC20 bridge */
    readonly vegaERC20SignerAdded: {
      /**
       * Format: int64
       * @description The time at which the block was produced
       * will be used to inform the core at what time
       * the stake was made unavailable.
       */
      readonly blockTime?: string;
      /** The ethereum address of the new signer */
      readonly newSigner?: string;
      /** The nonce create by the vega network used for this new signer */
      readonly nonce?: string;
    };
    /** A signer removed from the ERC20 bridge */
    readonly vegaERC20SignerRemoved: {
      /**
       * Format: int64
       * @description The time at which the block was produced
       * will be used to inform the core at what time
       * the stake was made unavailable.
       */
      readonly blockTime?: string;
      /** The nonce create by the vega network used for this old signer */
      readonly nonce?: string;
      /** The ethereum address of the old signer */
      readonly oldSigner?: string;
    };
    /** The threshold have been updated on the multisigcontrol */
    readonly vegaERC20ThresholdSet: {
      /**
       * Format: int64
       * @description The time at which the block was produced
       * will be used to inform the core at what time
       * the stake was made unavailable.
       */
      readonly blockTime?: string;
      /**
       * The new threshold
       * Format: int64
       */
      readonly newThreshold?: number;
      /** The nonce create by the vega network */
      readonly nonce?: string;
    };
    readonly vegaERC20Update: {
      /**
       * The lifetime limits deposit per address.
       * This is will be interpreted against the asset decimals.
       * note: this is a temporary measure that can be changed by governance
       */
      readonly lifetimeLimit?: string;
      /**
       * The maximum you can withdraw instantly. All withdrawals over the threshold will be delayed by the withdrawal delay.
       * There’s no limit on the size of a withdrawal
       * note: this is a temporary measure that can be changed by governance
       */
      readonly withdrawThreshold?: string;
    };
    /** An asset withdrawal for an ERC20 token */
    readonly vegaERC20Withdrawal: {
      /** The reference nonce used for the transaction */
      readonly referenceNonce?: string;
      /** The target Ethereum wallet address */
      readonly targetEthereumAddress?: string;
      /** The Vega network internal identifier of the asset */
      readonly vegaAssetId?: string;
    };
    /** An extension of data required for the withdraw submissions */
    readonly vegaErc20WithdrawExt: {
      /** The address into which the bridge will release the funds */
      readonly receiverAddress?: string;
    };
    /** Future product configuration */
    readonly vegaFutureProduct: {
      /** The binding between the data source spec and the settlement data */
      readonly dataSourceSpecBinding?: components['schemas']['vegaDataSourceSpecToFutureBinding'];
      /** The data source spec describing the data source for settlement */
      readonly dataSourceSpecForSettlementData?: components['schemas']['vegaDataSourceDefinition'];
      /** The external data source spec describing the data source of trading termination */
      readonly dataSourceSpecForTradingTermination?: components['schemas']['vegaDataSourceDefinition'];
      /** Product quote name */
      readonly quoteName?: string;
      /** Asset ID for the product's settlement asset */
      readonly settlementAsset?: string;
    };
    /** Instrument configuration */
    readonly vegaInstrumentConfiguration: {
      /** Instrument code, human-readable shortcode used to describe the instrument */
      readonly code?: string;
      /** Future */
      readonly future?: components['schemas']['vegaFutureProduct'];
      /** Instrument name */
      readonly name?: string;
    };
    readonly vegaKeyValueBundle: {
      readonly key?: string;
      readonly tolerance?: string;
      readonly value?: components['schemas']['vegaStateVarValue'];
    };
    /** LiquidityMonitoringParameters contains settings used for liquidity monitoring */
    readonly vegaLiquidityMonitoringParameters: {
      /**
       * Specifies by how many seconds an auction should be extended if leaving the auction were to trigger a liquidity auction
       * Format: int64
       */
      readonly auctionExtension?: string;
      /** Specifies parameters related to target stake calculation */
      readonly targetStakeParameters?: components['schemas']['vegaTargetStakeParameters'];
      /** Specifies the triggering ratio for entering liquidity auction */
      readonly triggeringRatio?: string;
    };
    /** Represents a liquidity order */
    readonly vegaLiquidityOrder: {
      /** The offset/amount of units away for the order */
      readonly offset?: string;
      /**
       * The relative proportion of the commitment to be allocated at a price level
       * Format: int64
       */
      readonly proportion?: number;
      /** The pegged reference point for the order */
      readonly reference?: components['schemas']['vegaPeggedReference'];
    };
    /** Risk model parameters for log normal */
    readonly vegaLogNormalModelParams: {
      /**
       * Mu parameter, annualised growth rate of the underlying asset
       * Format: double
       */
      readonly mu?: number;
      /**
       * R parameter, annualised growth rate of the risk-free asset, used for discounting of future cash flows, can be any real number
       * Format: double
       */
      readonly r?: number;
      /**
       * Sigma parameter, annualised volatility of the underlying asset, must be a strictly non-negative real number
       * Format: double
       */
      readonly sigma?: number;
    };
    /** Risk model for log normal */
    readonly vegaLogNormalRiskModel: {
      /** Risk model parameters for log normal */
      readonly params?: components['schemas']['vegaLogNormalModelParams'];
      /**
       * Risk Aversion Parameter
       * Format: double
       */
      readonly riskAversionParameter?: number;
      /**
       * Tau parameter of the risk model, projection horizon measured as a year fraction used in the expected shortfall calculation to obtain the maintenance margin, must be a strictly non-negative real number
       * Format: double
       */
      readonly tau?: number;
    };
    readonly vegaMatrixValue: {
      readonly value?: readonly components['schemas']['vegaVectorValue'][];
    };
    /** Represents a network parameter on Vega */
    readonly vegaNetworkParameter: {
      /** The unique key */
      readonly key?: string;
      /** The value for the network parameter */
      readonly value?: string;
    };
    /** New asset on Vega */
    readonly vegaNewAsset: {
      /** The configuration of the new asset */
      readonly changes?: components['schemas']['vegaAssetDetails'];
    };
    /**
     * @description Freeform proposal
     * This message is just used as a placeholder to sort out the nature of the
     * proposal once parsed.
     */
    readonly vegaNewFreeform: Record<string, never>;
    /** New market on Vega */
    readonly vegaNewMarket: {
      /** The configuration of the new market */
      readonly changes?: components['schemas']['vegaNewMarketConfiguration'];
    };
    /** Configuration for a new market on Vega */
    readonly vegaNewMarketConfiguration: {
      /**
       * Decimal places used for the new market, sets the smallest price increment on the book
       * Format: uint64
       */
      readonly decimalPlaces?: string;
      /** New market instrument configuration */
      readonly instrument?: components['schemas']['vegaInstrumentConfiguration'];
      /** Liquidity monitoring parameters */
      readonly liquidityMonitoringParameters?: components['schemas']['vegaLiquidityMonitoringParameters'];
      /** Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected */
      readonly logNormal?: components['schemas']['vegaLogNormalRiskModel'];
      /**
       * Percentage move up and down from the mid price which specifies the range of
       * price levels over which automated liquidity provision orders will be deployed
       */
      readonly lpPriceRange?: string;
      /** Optional new market meta data, tags */
      readonly metadata?: readonly string[];
      /**
       * Decimal places for order sizes, sets what size the smallest order / position on the market can be
       * Format: int64
       */
      readonly positionDecimalPlaces?: string;
      /** Price monitoring parameters */
      readonly priceMonitoringParameters?: components['schemas']['vegaPriceMonitoringParameters'];
      /** Simple risk model parameters, valid only if MODEL_SIMPLE is selected */
      readonly simple?: components['schemas']['vegaSimpleModelParams'];
    };
    /**
     * Type values for an order
     * @description - TYPE_UNSPECIFIED: Default value, always invalid
     *  - TYPE_LIMIT: Used for Limit orders
     *  - TYPE_MARKET: Used for Market orders
     *  - TYPE_NETWORK: Used for orders where the initiating party is the network (with distressed parties)
     * @default TYPE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaOrderType:
      | 'TYPE_UNSPECIFIED'
      | 'TYPE_LIMIT'
      | 'TYPE_MARKET'
      | 'TYPE_NETWORK';
    /**
     * Pegged orders are limit orders where the price is specified in the form REFERENCE +/- OFFSET
     * They can be used for any limit order that is valid during continuous trading
     */
    readonly vegaPeggedOrder: {
      /** Offset from the price reference */
      readonly offset?: string;
      /** The price point the order is linked to */
      readonly reference?: components['schemas']['vegaPeggedReference'];
    };
    /**
     * A pegged reference defines which price point a pegged order is linked to - meaning
     * the price for a pegged order is calculated from the value of the reference price point
     * @description - PEGGED_REFERENCE_UNSPECIFIED: Default value for PeggedReference, no reference given
     *  - PEGGED_REFERENCE_MID: Mid price reference
     *  - PEGGED_REFERENCE_BEST_BID: Best bid price reference
     *  - PEGGED_REFERENCE_BEST_ASK: Best ask price reference
     * @default PEGGED_REFERENCE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaPeggedReference:
      | 'PEGGED_REFERENCE_UNSPECIFIED'
      | 'PEGGED_REFERENCE_MID'
      | 'PEGGED_REFERENCE_BEST_BID'
      | 'PEGGED_REFERENCE_BEST_ASK';
    /** PriceMonitoringParameters contains a collection of triggers to be used for a given market */
    readonly vegaPriceMonitoringParameters: {
      readonly triggers?: readonly components['schemas']['vegaPriceMonitoringTrigger'][];
    };
    /** PriceMonitoringTrigger holds together price projection horizon τ, probability level p, and auction extension duration */
    readonly vegaPriceMonitoringTrigger: {
      /**
       * Price monitoring auction extension duration in seconds should the price
       * breach its theoretical level over the specified horizon at the specified
       * probability level
       * Format: int64
       */
      readonly auctionExtension?: string;
      /**
       * Price monitoring projection horizon τ in seconds
       * Format: int64
       */
      readonly horizon?: string;
      /** Price monitoring probability level p */
      readonly probability?: string;
    };
    /** @description The rationale behind a proposal. */
    readonly vegaProposalRationale: {
      /**
       * @description Description to show a short title / something in case the link goes offline.
       * This is to be between 0 and 20k unicode characters.
       * This is mandatory for all proposals.
       */
      readonly description?: string;
      /**
       * @description Title to be used to give a short description of the proposal in lists.
       * This is to be between 0 and 100 unicode characters.
       * This is mandatory for all proposals.
       */
      readonly title?: string;
    };
    /** Terms for a governance proposal on Vega */
    readonly vegaProposalTerms: {
      /**
       * Timestamp (Unix time in seconds) when voting closes for this proposal,
       * constrained by `minClose` and `maxClose` network parameters
       * Format: int64
       */
      readonly closingTimestamp?: string;
      /**
       * Timestamp (Unix time in seconds) when proposal gets enacted (if passed),
       * constrained by `minEnact` and `maxEnact` network parameters
       * Format: int64
       */
      readonly enactmentTimestamp?: string;
      /** Proposal change for creating new assets on Vega */
      readonly newAsset?: components['schemas']['vegaNewAsset'];
      /**
       * Proposal change for a freeform request, which can be voted on but does not change the behaviour of the system,
       * and can be used to gauge community sentiment
       */
      readonly newFreeform?: components['schemas']['vegaNewFreeform'];
      /** Proposal change for creating new market on Vega */
      readonly newMarket?: components['schemas']['vegaNewMarket'];
      /** Proposal change for updating an asset */
      readonly updateAsset?: components['schemas']['vegaUpdateAsset'];
      /** Proposal change for modifying an existing market on Vega */
      readonly updateMarket?: components['schemas']['vegaUpdateMarket'];
      /** Proposal change for updating Vega network parameters */
      readonly updateNetworkParameter?: components['schemas']['vegaUpdateNetworkParameter'];
      /**
       * Validation timestamp (Unix time in seconds)
       * Format: int64
       */
      readonly validationTimestamp?: string;
    };
    readonly vegaScalarValue: {
      readonly value?: string;
    };
    /**
     * A side relates to the direction of an order, to Buy, or Sell
     * @description - SIDE_UNSPECIFIED: Default value, always invalid
     *  - SIDE_BUY: Buy order
     *  - SIDE_SELL: Sell order
     * @default SIDE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaSide: 'SIDE_UNSPECIFIED' | 'SIDE_BUY' | 'SIDE_SELL';
    /** Risk model parameters for simple modelling */
    readonly vegaSimpleModelParams: {
      /**
       * Pre-defined risk factor value for long
       * Format: double
       */
      readonly factorLong?: number;
      /**
       * Pre-defined risk factor value for short
       * Format: double
       */
      readonly factorShort?: number;
      /**
       * Pre-defined maximum price move up that the model considers as valid
       * Format: double
       */
      readonly maxMoveUp?: number;
      /**
       * Pre-defined minimum price move down that the model considers as valid
       * Format: double
       */
      readonly minMoveDown?: number;
      /**
       * Pre-defined constant probability of trading
       * Format: double
       */
      readonly probabilityOfTrading?: number;
    };
    readonly vegaStakeDeposited: {
      /** The amount deposited (base 10) */
      readonly amount?: string;
      /**
       * Format: int64
       * @description The time at which the block was produced
       * will be used to inform the core at what time
       * the stake started to be available.
       */
      readonly blockTime?: string;
      /** Ethereum Address of the user depositing stake (hex encode with 0x prefix) */
      readonly ethereumAddress?: string;
      /** The public of the party receiving the stake deposit (hex encode) */
      readonly vegaPublicKey?: string;
    };
    readonly vegaStakeRemoved: {
      /** The amount removed (base 10) */
      readonly amount?: string;
      /**
       * Format: int64
       * @description The time at which the block was produced
       * will be used to inform the core at what time
       * the stake was made unavailable.
       */
      readonly blockTime?: string;
      /** Ethereum address of the user removing stake (hex encode with 0x prefix) */
      readonly ethereumAddress?: string;
      /** The public key of the party from which to remove stake (hex encode) */
      readonly vegaPublicKey?: string;
    };
    readonly vegaStakeTotalSupply: {
      /** The address of the staking asset */
      readonly tokenAddress?: string;
      /** The total supply observed for the token */
      readonly totalSupply?: string;
    };
    readonly vegaStakingEvent: {
      /**
       * The block in which the transaction was added
       * Format: uint64
       */
      readonly block?: string;
      /**
       * Index of the log in the transaction
       * Format: uint64
       */
      readonly index?: string;
      readonly stakeDeposited?: components['schemas']['vegaStakeDeposited'];
      readonly stakeRemoved?: components['schemas']['vegaStakeRemoved'];
      readonly totalSupply?: components['schemas']['vegaStakeTotalSupply'];
    };
    readonly vegaStateValueProposal: {
      /** event identifier */
      readonly eventId?: string;
      /** key value tolerance triplets */
      readonly kvb?: readonly components['schemas']['vegaKeyValueBundle'][];
      /** state variable identifier */
      readonly stateVarId?: string;
    };
    readonly vegaStateVarValue: {
      readonly matrixVal?: components['schemas']['vegaMatrixValue'];
      readonly scalarVal?: components['schemas']['vegaScalarValue'];
      readonly vectorVal?: components['schemas']['vegaVectorValue'];
    };
    /** TargetStakeParameters contains parameters used in target stake calculation */
    readonly vegaTargetStakeParameters: {
      /**
       * Specifies scaling factors used in target stake calculation
       * Format: double
       */
      readonly scalingFactor?: number;
      /**
       * Specifies length of time window expressed in seconds for target stake calculation
       * Format: int64
       */
      readonly timeWindow?: string;
    };
    /** Update an existing asset on Vega */
    readonly vegaUpdateAsset: {
      /** The ID of the asset to be updated */
      readonly assetId?: string;
      /** The changes to apply on an existing asset */
      readonly changes?: components['schemas']['vegaAssetDetailsUpdate'];
    };
    /** Future product configuration */
    readonly vegaUpdateFutureProduct: {
      /** The binding between the data source spec and the settlement data */
      readonly dataSourceSpecBinding?: components['schemas']['vegaDataSourceSpecToFutureBinding'];
      /** The data source spec describing the data of settlement data */
      readonly dataSourceSpecForSettlementData?: components['schemas']['vegaDataSourceDefinition'];
      /** The data source spec describing the data source for trading termination */
      readonly dataSourceSpecForTradingTermination?: components['schemas']['vegaDataSourceDefinition'];
      /** Human-readable name/abbreviation of the quote name */
      readonly quoteName?: string;
    };
    /** Instrument configuration */
    readonly vegaUpdateInstrumentConfiguration: {
      /** Instrument code, human-readable shortcode used to describe the instrument */
      readonly code?: string;
      /** Future */
      readonly future?: components['schemas']['vegaUpdateFutureProduct'];
    };
    /** Update an existing market on Vega */
    readonly vegaUpdateMarket: {
      /** The updated configuration of the market */
      readonly changes?: components['schemas']['vegaUpdateMarketConfiguration'];
      /** The identifier of the market to update */
      readonly marketId?: string;
    };
    /** Configuration to update a market on Vega */
    readonly vegaUpdateMarketConfiguration: {
      /** Updated market instrument configuration */
      readonly instrument?: components['schemas']['vegaUpdateInstrumentConfiguration'];
      /** Liquidity monitoring parameters */
      readonly liquidityMonitoringParameters?: components['schemas']['vegaLiquidityMonitoringParameters'];
      /** Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected */
      readonly logNormal?: components['schemas']['vegaLogNormalRiskModel'];
      /**
       * Percentage move up and down from the mid price which specifies the range of
       * price levels over which automated liquidity provision orders will be deployed
       */
      readonly lpPriceRange?: string;
      /** Optional market metadata, tags */
      readonly metadata?: readonly string[];
      /** Price monitoring parameters */
      readonly priceMonitoringParameters?: components['schemas']['vegaPriceMonitoringParameters'];
      /** Simple risk model parameters, valid only if MODEL_SIMPLE is selected */
      readonly simple?: components['schemas']['vegaSimpleModelParams'];
    };
    /** Update network configuration on Vega */
    readonly vegaUpdateNetworkParameter: {
      /** The network parameter to update */
      readonly changes?: components['schemas']['vegaNetworkParameter'];
    };
    readonly vegaVectorValue: {
      readonly value?: readonly string[];
    };
    /**
     * Vote value
     * @description - VALUE_UNSPECIFIED: Default value, always invalid
     *  - VALUE_NO: A vote against the proposal
     *  - VALUE_YES: A vote in favour of the proposal
     * @default VALUE_UNSPECIFIED
     * @enum {string}
     */
    readonly vegaVoteValue: 'VALUE_UNSPECIFIED' | 'VALUE_NO' | 'VALUE_YES';
    /** Withdrawal external details */
    readonly vegaWithdrawExt: {
      /** ERC20 withdrawal details */
      readonly erc20?: components['schemas']['vegaErc20WithdrawExt'];
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {
  BlockExplorer_Info: {
    /**
     * Info
     * @description Retrieves information about the block explorer.
     * Response contains a semver formatted version of the data node and the commit hash, from which the block explorer was built,
     */
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          readonly 'application/json': components['schemas']['v1InfoResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          readonly 'application/json': components['schemas']['googlerpcStatus'];
        };
      };
    };
  };
  BlockExplorer_ListTransactions: {
    /**
     * List transactions
     * @description List transactions from the Vega blockchain
     */
    parameters?: {
      /** @description The number of transactions to be returned from the blockchain. */
      /** @description An optional cursor to paginate the request. */
      /** @description An optional cursor to paginate the request. */
      readonly query?: {
        limit?: number;
        before?: string;
        after?: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          readonly 'application/json': components['schemas']['v1ListTransactionsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          readonly 'application/json': components['schemas']['googlerpcStatus'];
        };
      };
    };
  };
  BlockExplorer_GetTransaction: {
    /**
     * Get transaction
     * @description Get a transaction from the Vega blockchain
     */
    parameters: {
      /** @description The hash of the transaction */
      readonly path: {
        hash: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          readonly 'application/json': components['schemas']['v1GetTransactionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          readonly 'application/json': components['schemas']['googlerpcStatus'];
        };
      };
    };
  };
}
