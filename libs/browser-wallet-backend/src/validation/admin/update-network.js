/* eslint-disable */
/// Autogenerated by 'scripts/compile-ajv-schema.js' target 'schemas'
const validate = validate14;
function validate14(
  data,
  { instancePath = '', parentData, parentDataProperty, rootData = data } = {}
) {
  let vErrors = null;
  let errors = 0;
  if (data && typeof data == 'object' && !Array.isArray(data)) {
    if (data.name === undefined) {
      const err0 = {
        instancePath,
        schemaPath: '#/required',
        keyword: 'required',
        params: { missingProperty: 'name' },
        message: "must have required property '" + 'name' + "'",
      };
      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }
      errors++;
    }
    if (data.api === undefined) {
      const err1 = {
        instancePath,
        schemaPath: '#/required',
        keyword: 'required',
        params: { missingProperty: 'api' },
        message: "must have required property '" + 'api' + "'",
      };
      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }
      errors++;
    }
    if (data.apps === undefined) {
      const err2 = {
        instancePath,
        schemaPath: '#/required',
        keyword: 'required',
        params: { missingProperty: 'apps' },
        message: "must have required property '" + 'apps' + "'",
      };
      if (vErrors === null) {
        vErrors = [err2];
      } else {
        vErrors.push(err2);
      }
      errors++;
    }
    for (const key0 in data) {
      if (
        !(
          key0 === 'name' ||
          key0 === 'metadata' ||
          key0 === 'api' ||
          key0 === 'apps'
        )
      ) {
        const err3 = {
          instancePath,
          schemaPath: '#/additionalProperties',
          keyword: 'additionalProperties',
          params: { additionalProperty: key0 },
          message: 'must NOT have additional properties',
        };
        if (vErrors === null) {
          vErrors = [err3];
        } else {
          vErrors.push(err3);
        }
        errors++;
      }
    }
    if (data.name !== undefined) {
      if (typeof data.name !== 'string') {
        const err4 = {
          instancePath: instancePath + '/name',
          schemaPath: '#/properties/name/type',
          keyword: 'type',
          params: { type: 'string' },
          message: 'must be string',
        };
        if (vErrors === null) {
          vErrors = [err4];
        } else {
          vErrors.push(err4);
        }
        errors++;
      }
      if (errors > 0) {
        const emErrs0 = [];
        for (const err5 of vErrors) {
          if (
            err5.keyword !== 'errorMessage' &&
            !err5.emUsed &&
            (err5.instancePath === instancePath + '/name' ||
              (err5.instancePath.indexOf(instancePath + '/name') === 0 &&
                err5.instancePath[instancePath + '/name'.length] === '/')) &&
            err5.schemaPath.indexOf('#/properties/name') === 0 &&
            err5.schemaPath['#/properties/name'.length] === '/'
          ) {
            emErrs0.push(err5);
            err5.emUsed = true;
          }
        }
        if (emErrs0.length) {
          const err6 = {
            instancePath: instancePath + '/name',
            schemaPath: '#/properties/name/errorMessage',
            keyword: 'errorMessage',
            params: { errors: emErrs0 },
            message: '`name` must be given',
          };
          if (vErrors === null) {
            vErrors = [err6];
          } else {
            vErrors.push(err6);
          }
          errors++;
        }
        const emErrs1 = [];
        for (const err7 of vErrors) {
          if (!err7.emUsed) {
            emErrs1.push(err7);
          }
        }
        vErrors = emErrs1;
        errors = emErrs1.length;
      }
    }
    if (data.metadata !== undefined) {
      let data1 = data.metadata;
      if (Array.isArray(data1)) {
        const len0 = data1.length;
        for (let i0 = 0; i0 < len0; i0++) {
          let data2 = data1[i0];
          if (data2 && typeof data2 == 'object' && !Array.isArray(data2)) {
            if (data2.key === undefined) {
              const err8 = {
                instancePath: instancePath + '/metadata/' + i0,
                schemaPath: '#/properties/metadata/items/required',
                keyword: 'required',
                params: { missingProperty: 'key' },
                message: "must have required property '" + 'key' + "'",
              };
              if (vErrors === null) {
                vErrors = [err8];
              } else {
                vErrors.push(err8);
              }
              errors++;
            }
            if (data2.value === undefined) {
              const err9 = {
                instancePath: instancePath + '/metadata/' + i0,
                schemaPath: '#/properties/metadata/items/required',
                keyword: 'required',
                params: { missingProperty: 'value' },
                message: "must have required property '" + 'value' + "'",
              };
              if (vErrors === null) {
                vErrors = [err9];
              } else {
                vErrors.push(err9);
              }
              errors++;
            }
            for (const key1 in data2) {
              if (!(key1 === 'key' || key1 === 'value')) {
                const err10 = {
                  instancePath: instancePath + '/metadata/' + i0,
                  schemaPath:
                    '#/properties/metadata/items/additionalProperties',
                  keyword: 'additionalProperties',
                  params: { additionalProperty: key1 },
                  message: 'must NOT have additional properties',
                };
                if (vErrors === null) {
                  vErrors = [err10];
                } else {
                  vErrors.push(err10);
                }
                errors++;
              }
            }
            if (data2.key !== undefined) {
              if (typeof data2.key !== 'string') {
                const err11 = {
                  instancePath: instancePath + '/metadata/' + i0 + '/key',
                  schemaPath: '#/properties/metadata/items/properties/key/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                };
                if (vErrors === null) {
                  vErrors = [err11];
                } else {
                  vErrors.push(err11);
                }
                errors++;
              }
            }
            if (data2.value !== undefined) {
              if (typeof data2.value !== 'string') {
                const err12 = {
                  instancePath: instancePath + '/metadata/' + i0 + '/value',
                  schemaPath:
                    '#/properties/metadata/items/properties/value/type',
                  keyword: 'type',
                  params: { type: 'string' },
                  message: 'must be string',
                };
                if (vErrors === null) {
                  vErrors = [err12];
                } else {
                  vErrors.push(err12);
                }
                errors++;
              }
            }
          } else {
            const err13 = {
              instancePath: instancePath + '/metadata/' + i0,
              schemaPath: '#/properties/metadata/items/type',
              keyword: 'type',
              params: { type: 'object' },
              message: 'must be object',
            };
            if (vErrors === null) {
              vErrors = [err13];
            } else {
              vErrors.push(err13);
            }
            errors++;
          }
        }
      } else {
        const err14 = {
          instancePath: instancePath + '/metadata',
          schemaPath: '#/properties/metadata/type',
          keyword: 'type',
          params: { type: 'array' },
          message: 'must be array',
        };
        if (vErrors === null) {
          vErrors = [err14];
        } else {
          vErrors.push(err14);
        }
        errors++;
      }
    }
    if (data.api !== undefined) {
      let data5 = data.api;
      if (!(data5 && typeof data5 == 'object' && !Array.isArray(data5))) {
        const err15 = {
          instancePath: instancePath + '/api',
          schemaPath: '#/properties/api/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
        };
        if (vErrors === null) {
          vErrors = [err15];
        } else {
          vErrors.push(err15);
        }
        errors++;
      }
    }
    if (data.apps !== undefined) {
      let data6 = data.apps;
      if (!(data6 && typeof data6 == 'object' && !Array.isArray(data6))) {
        const err16 = {
          instancePath: instancePath + '/apps',
          schemaPath: '#/properties/apps/type',
          keyword: 'type',
          params: { type: 'object' },
          message: 'must be object',
        };
        if (vErrors === null) {
          vErrors = [err16];
        } else {
          vErrors.push(err16);
        }
        errors++;
      }
    }
  } else {
    const err17 = {
      instancePath,
      schemaPath: '#/type',
      keyword: 'type',
      params: { type: 'object' },
      message: 'must be object',
    };
    if (vErrors === null) {
      vErrors = [err17];
    } else {
      vErrors.push(err17);
    }
    errors++;
  }
  if (errors > 0) {
    const emErrs2 = [];
    for (const err18 of vErrors) {
      if (
        err18.keyword !== 'errorMessage' &&
        !err18.emUsed &&
        (err18.instancePath === instancePath ||
          (err18.instancePath.indexOf(instancePath) === 0 &&
            err18.instancePath[instancePath.length] === '/')) &&
        err18.schemaPath.indexOf('#') === 0 &&
        err18.schemaPath['#'.length] === '/'
      ) {
        emErrs2.push(err18);
        err18.emUsed = true;
      }
    }
    if (emErrs2.length) {
      const err19 = {
        instancePath,
        schemaPath: '#/errorMessage',
        keyword: 'errorMessage',
        params: { errors: emErrs2 },
        message:
          '`admin.update_network` must only be given `name`, `metadata`, `api`, `apps`',
      };
      if (vErrors === null) {
        vErrors = [err19];
      } else {
        vErrors.push(err19);
      }
      errors++;
    }
    const emErrs3 = [];
    for (const err20 of vErrors) {
      if (!err20.emUsed) {
        emErrs3.push(err20);
      }
    }
    vErrors = emErrs3;
    errors = emErrs3.length;
  }
  validate14.errors = vErrors;
  return errors === 0;
}

export { validate14 as default, validate };
